<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>avrdude on Goofing Osamu</title>
    <link>/tags/avrdude/</link>
    <description>Recent content in avrdude on Goofing Osamu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 10 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/avrdude/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ATmega328P (4)</title>
      <link>/jp/2020/03/10/atmega328p-4/</link>
      <pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/10/atmega328p-4/</guid>
      <description>前回に続きArduino Uno/Nano に使われている基本のシリアルAVRの ATmega328P を中心としてAVRチップのプログラムの勉強・練習の続きをしました。
AVRのコーディング上の注意点 以下をAVRのコーディング上の注意点の参考にしました。
 2003年出版のIAR CベースのAVR035: Efficient C Coding for AVR 2011年出版のGCC4.5ベースのAtmel AVR4027: Tips and Tricks to Optimize Your C Code for 8-bit AVR Microcontrollers  わたしの現在の開発環境で使うのは、avr-gcc (GCC) 5.4.0です。 8 bitのATmega328Pぐらいにフォーカスして、現在の開発環境下で私なりに検討して、 ある程度の憶測も折り込み、よくまとまっていたAVR035文書の結論を以下に書きなお して見ました。
あまり頑張り過ぎることは無いと考えています。無理がある時には、コードを凝るの ではなく、所詮趣味でなので実現する機能を削るとか、値段は知れているので高性能 のチップに乗り換えるとかする方が良いのでしょう。
そういった意味では、裸のavr-gcc+avr-libcでの開発に拘らずに、Arduino系のインフ ラを利用したコード開発をすれば楽になる面もあるのも事実です。このメモ作成は、 あくまでAVRのコーディングの基礎学習行為の備忘録です。
Hints to Reduce Code Size  Compile with full size optimization. (use avr-gcc -s option) Use local variables whenever possible. Use the smallest explicit applicable data type such as uint8_t with &amp;lt;stdint.</description>
    </item>
    
    <item>
      <title>ATmega328P (3)</title>
      <link>/jp/2020/03/06/atmega328p-3/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/06/atmega328p-3/</guid>
      <description>前回に続きArduino Uno/Nano に使われている基本のシリアルAVRの ATmega328P を中心としてAVRチップのプログラムの勉強・練習の続きとして、 「AVR Libc Reference Manual」を読み込んでAVR独特の世界をみました。
メモリー PCでのプログラムとはメモリー関係は、少々勝手が違い、IO関係を直接触る上、 メモリー空間も狭いので要注意です。
さらにATmega328Pを含むAVRはﾌﾟﾛｸﾞﾗﾑとﾃﾞｰﾀに対してﾒﾓﾘとﾊﾞｽを分離する ﾊｰﾊﾞｰﾄﾞ構造を使用し、メモリーアドレス空間もそれぞれ別です。 （PCはﾌﾟﾛｸﾞﾗﾑとﾃﾞｰﾀがメモリーアドレス空間を共有するノイマン構造。）
 ﾌﾟﾛｸﾞﾗﾑは不揮発性のフラッシュに格納されます。 ﾃﾞｰﾀは通常の揮発性のSRAMに格納されます。 不揮発データーを格納する別のEEPROMもあります。  ATmega328Pだと：
 ﾌﾗｯｼｭ ﾒﾓﾘ容量 (ﾊﾞｲﾄ) 32K SRAM容量 (ﾊﾞｲﾄ) 2K EEPROM容量 (ﾊﾞｲﾄ) 1K  実際のデーターメモリー領域は以下です。
 ﾚｼﾞｽﾀ ﾌｧｲﾙ (32: 0x00-0x1F)　ーALUの汎用レジスタ I/Oﾚｼﾞｽﾀ (64: 0x20-0x5F) - アセンブラIN/OUT命令は0x20オフセットしたLDS/STS 拡張I/Oﾚｼﾞｽﾀ (160: 0x60-0xFF) 内蔵SRAM (2K: 0x100-0x3FFF)  IN/OUT命令関連のことがよく分からない。どうもAVRの前の世代のマイコン8051の命令 のことのようだ。アセンブラコード移植を意識しているようだ。INTEL系はIOは0x00から 始まる独立アドレス空間なので、アセンブラコードは0x20オフセットした LDS/STS命令に置き換えると言っているようです。
ﾌﾟﾛｸﾞﾗﾑ領域（フラッシュ）へのアクセスには専用のアセンブラコードLPM/SPMがあります。
EEPROM領域へのアクセスは専用のI/Oﾚｼﾞｽﾀ経由で行うようです。
Cコードからは、マクロが準備されているので、ﾌﾟﾛｸﾞﾗﾑ領域たやEEPROM領域へのアクセス には専用マクロ等を使うようだ。詳しくは「ATmega328Pマニュアル」の「ﾃﾞｰﾀ用EEPROMﾒﾓﾘ」や、 「AVR Libc Reference Manual」の「Data in Program Space」や、 avr/eeprom.h や avr/pgmspace.</description>
    </item>
    
    <item>
      <title>ATmega328P (2)</title>
      <link>/jp/2020/03/03/atmega328p-2/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/03/atmega328p-2/</guid>
      <description>Arduino Uno/Nano に使われている基本のシリアルAVRの ATmega328P を中心としてAVRチップのプログラムの練習の続きをしました。
確かにハードとして少々古い感はありますが、５V仕様で安価で入手簡単な開発 ボードがあるのが練習用にいい感じです。
開発環境 クロスコンパイル開発環境は以下でOK（2020/03, Debian stable buster）
 $ sudo apt install gcc-avr avr-libc binutils-avr  コードスタイル 以下色々なところからコードを引っ張ってくると、コードスタイルが混じって 見づらくなるし、手動で直すのもばかばかしいのでちょっとコードスタイル関係を 調べました。もともとK&amp;amp;R系のTAB無し2-4スペースインデントの 1TBS なので、色々のスタイルガイドを見て、結局 GOOGLEスタイル に最も共感しました。
今後はPython以外は全言語基本2スペースインデントにします。
VIMのモードライン&amp;copy;
// vim: set sts=2 sw=2 ft=c ai si et tw=80:  VIMのモードライン(SH)
# vim: set sts=2 sw=2 ft=sh ai si et tw=80:  VIMのモードライン(PYTHON)
# vim: set sts=4 sw=4 ft=python ai si et:  Cの自動リフォーマットは
 $ clang-format -style=Google -i filename.</description>
    </item>
    
    <item>
      <title>AVRISP markII mod-VCC (J)</title>
      <link>/jp/2020/02/27/avrisp-mod-j/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/02/27/avrisp-mod-j/</guid>
      <description>AVRチップのISPプログラマにAVR ISP markIIを使うと、対象AVRチップに別途電源供給 する必要があり、ISP出力のPIN#2にVCCを供給していた以前の TTL-232R-5V を使った自作プロクラマー を使うより煩雑でした。
そこで、AVR ISP markIIを改造し、ISP出力のPIN#2からVCCを供給出きるように改造し ました。
参考情報 いろんな人が同様の不便を感じ、AVRISP mkIIのUSB から電源を取り、ISP出力のPIN#2 に つなぎVCC電源供給ソースとする改造記事を書いています。以下の改造記事を参考に しました。
 http://www.webx.dk/avrisp-mk2-modding/ (3V/5V selectable, use own fuse, easy output) https://jeelabs.org/2010/04/02/avrisp-mkii-w-5v-power/ (nice input after poly fuse) https://forum.arduino.cc/index.php?topic=125502.0 (half ass fix, Nice pics of wiring, good output point) https://qiita.com/hideyuki/items/71381b741d89878e3e79 (Easy access via TP1, No fuse) http://shiozoku.blogspot.com/2014/02/avr-isp-mkii.html Use switch (No fuse, interesting use reminder) https://electronics.stackexchange.com/questions/286693/can-anything-be-done-about-this-avrisp-mkii-or-is-it-dead (Nice pics of wiring, not the same purpose, fix by bypassing broken DC/DC)　これは本改造とは違う修理改造。  どうもこれらの記事の基板の方が私の持っている基板より配線が太く見やすいです。</description>
    </item>
    
    <item>
      <title>ATmega328P (1)</title>
      <link>/jp/2020/02/21/atmega328p-1/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/02/21/atmega328p-1/</guid>
      <description>AVRチップのISP経由プログラムの練習をします。
ATmega328P は手元にあったブレッドボードに挿せるArduino Nanoのコンパチボードや本物の Uno等を使ってます。
プロクラマー これには、 TTL-232R-5V を使った自作プロクラマー を使うのも良いのですが、最近Atmel AVR ISP mkIIをただで人からもらったので それを使います。
詳細な使用説明書（英文）： AVR ISP mkII User Guide
ソフト環境 Debian GNU/Linux buster=stable 環境です。
$ sudo apt install avrdude  接続 AVRISP mkIIのVCCは電源電圧監視用でAVRISP mkII側からは電源供給されませんので、 別途チップへの電源供給ソースが必要！Unoなら12V、NanoならUSBを必ずつなぐこと。
ちなみに、 TTL-232R-5V を使った自作プロクラマー は電源電圧供給していたので便利な面がありました。 不便なのでAVRISP mkIIのUSB 電源 と PIN#1 をつなぎ、電源供給ソースとする等の改造をしたい気もしますが 、 これはあとで考えましょう。
ISPケーブルの赤線は１ピン側です。
Uno Nano AVRISP mkII に赤いLEDがつきっぱなしは、ISPコネクター「差し込み忘れ」です。
AVRISP mkII に赤いLEDが点滅は、ISPコネクター「逆差し」です。
Uno $ sudo avrdude -c avrisp2 -P usb -p m328p -v avrdude: Version 6.</description>
    </item>
    
  </channel>
</rss>