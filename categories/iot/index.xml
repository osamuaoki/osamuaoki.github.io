<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>iot on Goofing Osamu</title>
    <link>/categories/iot/</link>
    <description>Recent content in iot on Goofing Osamu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="/categories/iot/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>QWFRTY配列</title>
      <link>/jp/2022/02/14/qwfrty/</link>
      <pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/02/14/qwfrty/</guid>
      <description>背景 MCUを使ったIOTの初等プロジェクトとして、cgc56というQMKを利用したキーボードを作りました。
デフォルトのキー配列に採用したのは、QWERTY配列でした。ずぼらな性格上、DVORAK, COLMAK, WORKMAN, COLEMAK-DHのいずれも学習障壁が高すぎました。(これらの有名配置だと、VIエディターでのカーソール移動がVIのデフォルト設定では難しくなってしまいます。)
ただ、元々は中指を伸ばして「E」を叩きづらいという個人的課題解決目的のキーボードでした。これだけならEとFのスワップで済ますのも良いのですが、それだけでは残念なので、苦労しない範囲でDVRAKの交互打鍵に近づくために「QWFRTY配列」を考え、最適化配列を考えてみました。
cgc56 QWFRTY キーボードデータ 簡易版
使ってみて意外とおもしろいので、ここに要点等をメモしておきます。
小さなキーボードでカーソールやINSまで押し込んだので、実際には最右下のキーは、カーソルキーが割り込みもう一つ右に離れています。 ただ直交系キーボード配列なので、比較的に使わない&amp;quot;/&amp;ldquo;キーだし、元々下のキーQWERTYよりは左によっているので問題はないようです。 ちなみに今回完成したキーボードは、PLANCKより4x14と幅があることを利用して、左右の手の間隔をとり、できた真ん中の余分の部分に頻出記号キーを押し込んでいます。
QWFRTY配列 私は、せっかく作ったQMKを利用した自作キーボードのいわゆる最適化キー配列として、11個のキーだけが標準の「QWERTY配列」から移動された配列としています。
名前は、１文字違いでややこしいですが、「QWFRTY配列」としました。キーは位置の要点を抜き出すと以下です。
 LEFT HAND RIGHT HAND │ Q │ W │_F_│ R │ T │ │ Y │_D_│_K_│_G_│ P │ │ A │_I_│_U_│_E_│_O_│ │_S_│_H_│_J_│ L │ ; │ │ Z │ X │ C │ V │ B │ │ N │ M │ , │ . │ / │ まあ、所詮実験レベルのお遊びですが、我ながら悪くない気もします。
QWERTY配列からの変更点（覚え方）: キーの移動を以下の様にとらえると覚えられます。</description>
    </item>
    
    <item>
      <title>STM32F411CE (1)</title>
      <link>/jp/2022/02/07/blackpill-1/</link>
      <pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/02/07/blackpill-1/</guid>
      <description>基本のSTM32F系の安価だけど、純正STMチップ(同等品でない)が載っていそうな 小型のデモボードとして、WeActのblackpillをAliexpressの正規ショップ から購入しました。STM32F411CEが載っています。
 WeActのデバイス情報 https://github.com/WeActTC/MiniSTM32F4x1  PCB回路要点    IC PIN 機能 動作     7 NRST RESET SW, PUSH=0 , NORMAL=1   44 BOOT0 BOOT SW, PUSH=1, NORMAL=0   20 PB2 / BOOT1 NORMAL=0 (pull down res.)   10 PA0 / WKUP1 USER KEY, NORMAL=1, PUSH=0   2 PC13 / BLUE LED, LED_ON=0    STM32のメモリー  0x0000 0000 - 0x0007 FFFF (REMAPされる) &amp;ndash; The code area  通常 BOOT0は押されていないので: Flash memoryをさしている  つまりユーザー作成のFirmware実行   BOOT0 pushed: System memory (BOOT0 pushed)  CU内臓のBOOTLOADERの実行, STM32F411の場合はUSB経由のDFUもサポート     0x2000 0000 - 0x2002 0000 SRAM1 (128 KB) &amp;ndash; The data area 0x0800 0000 - 0x0807 FFFF Flash memory Flash memory (512KB) 0x1FFF 0000 - 0x1FFF 77FF System memory (32MB)  STM32F103等だと、NativeでDFUをサポートしていなかったので、シリアル接続などでFlash memory内に小さめのHIDのBOOTLOADERを入れることがよく行われていたようだが、 互換性を求めないならDFUで充分と見ました。</description>
    </item>
    
    <item>
      <title>配線</title>
      <link>/jp/2022/01/28/wire-1/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/01/28/wire-1/</guid>
      <description>典型的配線材料 趣味の工作の基本配線材料を整理しました。
 基板上低電圧信号用 UEW電線 AWG-32 (0.2mm)　単線、5V 以下 基板上通常信号用 ジュンフロンETFE電線 AWG-30 単線 (0.26mm) 多色準備　Wirewrapにも使える 基板上電源線 TA (錫メッキ線) 0.5mm　単線 (AWG 24(0.51mm) 単線 の LAN cable使用線の流用) 基板間配線（コネクター使用圧着)はAWG 24(0.5mm)相当のヨリせん (多色準備?) 基板間配線（pin header経由直付け)はAWG 30(0.5mm)単線のWIREWRAP 基板間配線（PCB直付け)はAWG 30(0.5mm)単線のTHハンダ付け 電源: 15A current -&amp;gt; 0.8 mm2 -&amp;gt; 1mm -&amp;gt; AWG18のヨリせん  配線方法諸説  錫メッキ耐熱樹脂被覆導線をワイヤーストリッパー＋ハンダ付けで利用する配線方法  電子工作のヒント &amp;ndash; ジュンフロンAWG30使用(2000以前のページ?)、実用性高い &amp;ndash; 今の私の方法 愛用の工具と材料 (2007年) &amp;ndash; OK industries AWG30銀メッキKynar使用 &amp;ndash; 究極の実施例 &amp;ndash; 真似できない Circuit Board Prototyping Tips and Tricks Vector board, Dead bug, &amp;hellip; (2016) How to Solder properly || Through-hole (THT) &amp;amp; Surface-mount (SMD) Perfboard, solder wick (2017)   UEW線・錫メッキ線を使うELM-CHANの究極の配線方法 (1997-&amp;gt;2014年)  信号線: ポリウレタン銅線(φ0.</description>
    </item>
    
    <item>
      <title>MCU (AVRとARM) の周囲状況と比較</title>
      <link>/jp/2022/01/19/mcu-comp/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/01/19/mcu-comp/</guid>
      <description>MCUとそのプロトボード状況 AliExpressやbangoodを初めとした中華コマースサイトは便利なんだけど、魑魅魍魎の棲家ですね。
中華コマースサイトで売られる安いボードは実際に使っているMCUまで違う状況と知り驚いてます。ICチップパッケージの刻印が本家で中身が違うなら贋チップ使用というのでしょうが、堂々とICチップパッケージの刻印にコンパチ品が書いてあったり、高性能だったりするようです。
またPCB基板が同じPIN配置の製品ですが、回路配置利用権を考えると、ちょっとヤバいかもしれないので要注意。（ただ、小型のプロトボードはPINアウトを揃えると、必然的に本家のボードに似た回路配置になってしまう。PINアウトが同じこと自体は規制されないので判断は難しい。実際に入手し本家PCBと並べて詳細に比べないとコンパチPCB品が回路配置権を侵害したかどうかは判断できないので、入手前には無理。）
とりあえずネットで見つけた関連情報のリンクをリストしておきます。
 Teensy  https://www.pjrc.com/teensy/counterfeit.html &amp;ndash; Aliexpress販売のTeensyは本物でない。  本物のTeensy 2.0++は製造終了で欠品中(2022/Jan.)。AT90USB1286使用のコンパクトなボードはコンパチ品しか手に入らない状況。     ARM系(blue/blackpill)  STM32-base のboard紹介によると、安いblue/blackpillは贋STMチップが多いとのこと。 https://hackaday.com/2020/10/22/stm32-clones-the-good-the-bad-and-the-ugly/ https://www.cnx-software.com/2019/02/10/cs32-mcu-stm32-clone-bluepill-board/ https://www.cnx-software.com/2019/12/24/stm32-black-pill-board-features-stm32f4-cortex-m4-mcu-optional-spi-flash/ https://www.cnx-software.com/2020/03/22/how-to-detect-stm32-fakes/ https://github.com/WeActTC/MiniSTM32F4x1/blob/master/README.md WeActの製品情報  怪しいパチ物(PCBパターンが同等？旧タイプ？)を売っているVENDERの実名リストがある（Aliexpressでよく見るTZTは怪しいらしい！）     STM32F103コンパチチップ状況  GD32F103: https://www.gigadevice.com/products/microcontrollers/gd32/arm-cortex-m3/ &amp;ndash; Datasheet https://www.usenix.org/system/files/woot20-paper-obermaier.pdf &amp;ndash; 本物とコンパチチップのセキュリティー解析比較(USENIX, 2020以降) 評価 https://www.cnx-software.com/2015/12/21/gigadevice-gd32-is-a-faster-software-and-pin-to-pin-stm32-compatible-cortex-m3-mcu/ 評価 https://www.instructables.com/Alternative-to-STM32F103C8T6-by-GigaDevice/ コメント https://eetimes.itmedia.co.jp/ee/articles/2001/28/news032_2.html   ATmega328P (Arduino Unoのチップ)  贋物は不良症状としてスリープモードの電流が多いこともあるようです。流石に調査がしっかりしているとおもったら、部品の調査検定会社のYOUTUBE情報でした。   DS18B20 Temperature Sensors  https://www.cnx-software.com/2020/07/13/fake-ds18b20-temperature-sensors-counterfeit-clones/   FTDI FT232RLの贋物騒動 &amp;ndash; Windowsの正規品ドライバーで壊れる  https://hackaday.</description>
    </item>
    
    <item>
      <title>QMK (2)</title>
      <link>/jp/2022/01/18/qmk-2/</link>
      <pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/01/18/qmk-2/</guid>
      <description>手始めに、QMK : キーマップのカスタマイズ (2018年頃)も参考に、できるだけ今風の(2022年)qmkコマンドを使って、１つのキーのカスタムキーボードを作ります。
対象ハードはatmega32u4が載ったTeensy2.0の中華コンパチボードです。本物のTeensy2.0でないのでatmel-dfuがBOOTLOADERだったはずです。ただ、BOOTLOADERはISP接続で小さな(512 bytes)HIDデバイスのnanoBoot (w/LED)に書き換えています。
 .word 0x03EB // idVendor -- Vendor ID (Atmel VID, from LUFA) .word 0x2067 // idProduct -- Product ID (HID Class Bootloader PID, from LUFA) これってqmk-hidと同じIDです。ファームウエアーのサイズはqmk-hidの4KB(?)よりnanoBootは小さいメリットがあります。
ファームエアーのアップロードプロトコルは同じ　halfkeyコンパチのID違いなので、指定は同じにして良い気がします。
作成デバイスはメディアキーのMUTE１つのデバイスです。
テンプレート作成  $ qmk cd $ gitk --all ... (最新の「master」ブランチのリリースが0.15.15と確認) $ git checkout 0.15.15 $ git checkout -b osamu1 $ qmk new-keyboard Ψ Generating a new QMK keyboard directory Keyboard Name: one Keyboard Type: 1.</description>
    </item>
    
    <item>
      <title>QMK (1)</title>
      <link>/jp/2022/01/14/qmk-1/</link>
      <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/01/14/qmk-1/</guid>
      <description>どうもカスタムキーボードのフリーのファームウエアとしてはQMKが一番充実しているのですが、久しぶりにのぞくと2017年2月のころとかなり様子が変わっているようにも見えます。特に気になるのはconfig.jsonの存在です。
とにかくカバーするキーボードハードウエアー数が大きくなってきたので、リファクターして共通部分の重複回避を試みている様です。
復習を兼ねてコード・ドキュメントを追います。
qmkコマンドとビルド 最近、pip経由で導入する、非プログラマーにも使いやすいマルチプラットフォーム対応のUIを目指したpythonで書かれたthin wrapperのqmkというCLIコマンドが提供されています。
qmkコマンドは、作業環境設定や、firmwareのビルド、はたまた種々の処理プログラムの起動に用いるようです。でもビルドされるCコードのコアの部分はあまり変わっていないようです。
まず、Install Using pipに従い環境をDebian 11 (Bullseye/testing)に導入しました。
qmk setupの自動設定でチェックアウトされるレポは、git submoduleを使っていて、レボがうまくまとめられています。レポ内にグラフィクスなどを保存しなくなり、キーマッピングもキーボード間で共用可能なものをまとめたり、マッピングだけのユーザーカスタム化情報がメインのkeyboads/以下のソースツリー外に置けるようです。ただソースを理解するのが少々手間となりました。
qmkは、初期導入時に~/.bashrcを変更し、shellの環境変数QMK_HOMEにチェックアウトしたレポの場所を保存したようです。（手動でしたのかどうか忘れました）
qmkのコマンドの説明はQMK CLI Commandsにあります。
どうもビルドは公式にはqmkコマンドを使うようになっているそうですが、その背後で何がどうなっているのかが気になります。
レポを見ると、791b9cc652 (&amp;ldquo;remove all makefiles from keyboard directories&amp;rdquo;, 2017-09-27)で昔ビルドに使っていた各キーボード毎の独立のMakefileが無くなっています。だから、ビルドの実体はrootにあるMakefileがしているはずです。いかんせんrootのMakefileは複雑なので閉口でした。
今残っているrootにあるMakefileにからむのかがwebにあるエンドユーザー向けの説明ではよく分からないので、試しにrootにあるMakefileを無効なターゲットで動かすと以下のメッセージが出ます。
$ make help QMK Firmware 0.15.12 make: *** No rule to make target &#39;help&#39;. Stop. | | QMK&#39;s make format is: | make keyboard_folder:keymap_folder[:target] | | Where `keyboard_folder` is the path to the keyboard relative to | `qmk_firmware/keyboards/`, and `keymap_folder` is the name of the | keymap folder under that board&#39;s `keymaps/` directory.</description>
    </item>
    
    <item>
      <title>ATmega32u4 (4) --AT90USB1286も含めて...</title>
      <link>/jp/2021/12/11/atmega32u4-4/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/12/11/atmega32u4-4/</guid>
      <description>基本のUSB AVRのATmega32u4と AT90USB1286 を中心としたAVRチップに関して、ブートローダー関係を、１年半２年ぶりに見直し書きます。
開発環境 ATmega328P (2)の開発環境を再現すればOKです。
USB系のAVRで、変数名等の細かなところにとにかく疑問が出れば、/usr/lib/avr/include/以下を見れば分かります。。
 /usr/lib/avr/include/avr/iom32u4.h &amp;ndash; teensy2.0 (ATmega32u4) /usr/lib/avr/include/avr/iousb1286.h &amp;ndash; teensy2.0++ (AT90USB1286)  FUSEビットのSET FUSEビットは、プログラム設定されると「0」で、プログラム解除されると「1」です。 不揮発メモリーのリセット状態が1なので、こうされている理屈は分かるのですが、通常のPIN信号電位等と逆で混乱します。
 プログラム設定(条件合致) = 対応ビット 0 プログラム設定(条件不合致) = 対応ビット 1  電源投入時ちゃんとファームウエアーが立ち上がるには、BOOTRSTは1にして application reset (address 0x0000)としないといけません。 (BOOTRSTは0だと Reset vector = boot loader resetとなり、メモリー末尾に行きます。)
FUSEの設定変更(JTAG) FUSEの設定変更は当然ですが要注意です。　よく考えずにJTAGをENABLEしたら、一部GPIOピンが動作しなくなって驚きました。
BOOT MODE (HWBE)のこと USB系のAVRの起動の基本確認事項として、BOOTのモードの状況を確認します。
ARDUINO LEONARDO やTEENSY系の基板のPE2 (ALE,/HWBE)では、1K等で接地されています。だから、実際に出会うボードのリセットボタンが押された際のBOOT挙動は以下です。
 通常PE2は接地電位なので、リセットを押したらHWBEヒューズがON(0)にされてると、ブートローダーの起動となる。 強引にPE2(ALE)をVCCに繋いだ状態で、リセットだとHWBEヒューズ設定によらず、アプリファームが起動する。(その間1Kに電気が5mAも流れますが。) HWBEがOFF(1)の場合、PE2によらず常にアプリファームが起動する。  ISP接続によるMCUのプログラミング AVR-ISP II等を使うと、ブートローダーも何もない状態ででもISP接続でMCUに直接プログラム書き込みができます。
 http://ww1.microchip.com/downloads/en/Appnotes/doc2568.pdf http://ww1.microchip.com/downloads/en/AppNotes/doc1644.pdf  ブートローダーの書き換えにはこれを使います
確実ですが、接続が面倒でICピンを占領するので、定常的使用にはむきません。
TEENSY系でのISP接続でのブートローダー書き込み接続 TEENSY系はARDUINOのようなISP接続でのブートローダー書き込み専用コネクターはついていません． だから、AVRISP2から出ているケーブル端の以下のようなコネクター穴に、PIN-PINのアダプターを差し込みます。 (私の場合クリップケーブル端のデュポンコネクターの横穴はフラットケーブルの方向に向けてつけている。写真参照) 接続はこのPIN-PINのアダプター経由で連結したクリップをボード端の穴へ繋ぐのが簡単のようです。</description>
    </item>
    
    <item>
      <title>How to make ISP with TTL-232R-5V</title>
      <link>/en/2021/11/12/avrisp-alt/</link>
      <pubDate>Fri, 12 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>/en/2021/11/12/avrisp-alt/</guid>
      <description>This is my manual for TTL-232R-5V based ISP which I made several years ago. I moved this content from other place to make it easy to find. I still use this as my back up IPS. This is 5V only programmer.
I now use my Modified AVRISP MKII (in Japanese) as my main programmer. (If I every program AVR again.)
Circuit It&amp;rsquo;s a bit un-intuitive, but USB to TTL level RS-232 adapter (Serial adapter) can be used in a special bit-bang mode.</description>
    </item>
    
    <item>
      <title>ATmega32u4 (3)</title>
      <link>/jp/2020/04/05/atmega32u4-3/</link>
      <pubDate>Sun, 05 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/04/05/atmega32u4-3/</guid>
      <description>今回も引き続き基本のUSB AVRの ATmega32u4 を中心としたAVRチップに関して、Teensy 2.0の中華コンパチ評価ボード を用いて練習します。
割り込みVector表 アセンブラーとC言語で書かれたBootloaderからの起動を追いかけて、 電源投入(POR)やリセットボタンを押された際のMCU処理の流れが気に なりました。アセンブラーは、しっかり割り込みVector表があるのが 分かるのですが、C言語で書かれた場合特に明示的なテーブルが無いの にどうして割り込みVector表がプログラムされてくるのかがよく見え ませんでした。
C言語では割り込みルーチンはISR(&amp;lt;割り込みVector名&amp;gt;)という形で 関数として定義します。割り込みVector表自体は明示的にプログラムしません。
後で考えれば「なーんだ」でしたが、リンカーがコンパイル時に、 このISR()関数定義にあわせて、コンパイラー提供のスタートアップ コード中の確保されている割り込みVector表に、割り込みルーチンの アドレスを入れ完成するらしいと分かりました。確かによく見ると 割り込みVector表は、blink.lstに見当たらないが、blink.lss等 に定義されています。
ISP接続とUSB接続の干渉問題 ISP接続でブートローダーを導入した上で、その動作をUSB経由接続でアプリケーション のファームウエアーを導入して試そうとして見た際に、何度やっても電源投入で ファームウエアーが立ち上がらず、ブートローダーが立ち上がって悩みました。
問題はISP接続のリセット線が繋がっていたことです。通電時でも0.5Vぐらいの端子の ため、リセット線がPULL-DOWNされてリセットボタンが押されたのと同じ状態になって MCUが停止していたようです。さらにややこしくしたのは改造ISPではプログラマーの 電圧検知端子がプログラマーのVCCに繋がっているので、評価ボードからプログラマー に電気が供給され、電圧の高いリセットボタンが離された状態に一時的にでもなるのか 単にMCUの実行が止まるのではなくちゃんとリセットがかかり、ブートローダーが 立ち上がるようです。
少なくとも、プログラマーからのISP接続のリセット線だけは評価ボードから抜く 必要があります。まあ、VCCに繋がっている線も念のため抜くべきです。これらが ATmega32u4 (2) ISP接続 の「（使わないときは抜く）」という表記の背景です。
LED点滅 (Lチカ) まず、ブートローダー動作確認用にATmega32u4用に単純なLEDの点滅（通称Lチカ） というアプリケーションのファームウエアーのコードをPD0:PD7ピン全部を点滅 させるように書き換えます。こうすることでLチカが、このアプリケーションに よるのか、それともブートローダー中のコードによるのかを、外部LED挙動で 簡単に判別できるようになります。
#define F_CPU 16000000UL #include &amp;lt;avr/io.h&amp;gt; #include &amp;lt;util/delay.h&amp;gt; int main(void) { CLKPR = 0x80; CLKPR = 0; // set cpu prescale to 1 (disable CKDIV8) DDRD = 0xff; while (1) { PORTD = 0xff; _delay_ms(100); // 0.</description>
    </item>
    
    <item>
      <title>ATmega32u4 (2)</title>
      <link>/jp/2020/03/29/atmega32u4-2/</link>
      <pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/29/atmega32u4-2/</guid>
      <description>今回も引き続き基本のUSB AVRの ATmega32u4 を中心としたAVRチップのプログラム方法とその環境に関して、 調査と情報の整理をします。
ISP接続 Arduino系の開発ボードなら、6pinのICSPコネクターが付いているので 1pin(ポチマーク)側にAVRISP mkIIからのISP接続フラットケーブルの 赤線側を合わせて挿せば良い ので簡単でした。
ATmega32u4の開発ボードの SparkFun Pro Micro、 Teensy 2.0 や、AT90USB1286の開発ボードの Teensy 2.0++ などやそのコンパチ品はICSPコネクターが付いていないので 「直結接続」が必要です。
「直結接続」のために、以下の写真のように片側にクリップ、 片側にオスやメスのデュポンコネクターが付いたワイヤーを準備 しました。(AVR系をAVRUSP mkIIでISP書き換えするにはオスの デュポンコネクター版だけで充分ですが、将来ARM系のSTM32F等を ST-LINK/V2等で書き換えするのにはメスのデュポンコネクター版が あると便利そうなので両方準備してみました。)
左右逆にしないことが大事なので、接続関係をここにまとめます。
ISP接続フラットケーブルのコネクター （赤線側上です。コネクター穴側から見た「左図」が大事！)
 RED SIDE 赤線側 BTM VIEW コネクター穴側 TOP VIEW VCC 2 1 MISO MISO 1 2 VCC MOSI 4 3 SCK SCK 3 4 MOSI GND 6 5 RST RST 5 6 GND (こっちがメイン) Looking from Looking from the the hole side back of the connector hole 以下、開発ボードの端子はチップが載っている表側(TOP側)から、 USBコネクターを「左」に置き見て、「半時計回り」(CCW)で 「0スタート」(逆方向は-1スタート、角からスタート、重複命名有り) で位置表記し、ISPコネクターの端子は赤線側を上にして、 コネクター穴側から見て位置表記することとします。</description>
    </item>
    
    <item>
      <title>ATmega32u4 (1)</title>
      <link>/jp/2020/03/28/atmega32u4-1/</link>
      <pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/28/atmega32u4-1/</guid>
      <description>前々回・前回は、Arduino Uno/Nano に使われている基本のシリアルAVRの ATmega328P のプログラムの勉強・練習をしました。その結果チップ周辺の配線状態 確認をホストPCのターミナルからするシェルのような avrmon を書きました。
今回は基本のUSB AVRの ATmega32u4 を中心としたAVRチップのプログラム方法とその環境に関して、 調査と情報の整理をします。
ATmega32u4開発ボード ATmega32u4を5V 16MHzで使う開発ボードをしては、 Arduino Leonardo、 Arduino micro、 SparkFun Pro Micro、 RobotDyn Micro ATmega32U4-MU、 Teensy 2.0などや そのコンパチ品が通販サイト(例えば、 banggood、 aliexpress、 ebay )で出回っています。私はTeensy 2.0のコンパチ品を入手しました。
AVRへのプログラム導入 ATmega32u4へのプログラム導入アプローチは、 ATmega328Pへのプログラム導入アプローチ より選択肢が多く混乱しがちなので、以前書いた英語のメモ( Serial AVRや USB AVR )をベースに、日本語で以下に比較しながら状況を確認と整理をします。
Serial AVR Serial AVR (ATmega328P等) では、チップにプログラムを導入するのに 主に２つのアプローチがあります:
 ISP:  ホストPC上でavrdudeをISPモードで走らせ、AVR ISP mkII等の プログラマー経由でSPIポートに接続しATmega328Pを、ハードウエアー だけを用いチップを書き換えます。   Serial:  ホストPC上でavrdudeをArduinoモードで走らせ、D0/D1ピンに TTLレベルのRS-232C接続経由で、チップの上位アドレスに置かれた ブートローダーソフトの助けを受け、チップを書き換えます。 開発ボード上に、FT-232R や CH340 等のUSB-Serial変換チップが 載っている場合、ホストPCから外見的にはUSB接続に見えます。 昔のAtmel STK500 や、昔のArduinoにはブートローダー(4KB)が導入済みです。 Firmwareを探すときにこれらの古いのを踏まないように要注意です。 最近のArduino系の開発ボードでは、サイズを小さくしたブートローダー のOptiboot(512B)が導入済みです。(一押し！)    USB AVR USB AVR (ATmega32u4等) では、チップにプログラムを導入するのに 主に4つのアプローチがあります:</description>
    </item>
    
    <item>
      <title>ATmega328P (4)</title>
      <link>/jp/2020/03/10/atmega328p-4/</link>
      <pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/10/atmega328p-4/</guid>
      <description>前回に続きArduino Uno/Nano に使われている基本のシリアルAVRの ATmega328P を中心としてAVRチップのプログラムの勉強・練習の続きをしました。
AVRのコーディング上の注意点 以下をAVRのコーディング上の注意点の参考にしました。
 2003年出版のIAR CベースのAVR035: Efficient C Coding for AVR 2011年出版のGCC4.5ベースのAtmel AVR4027: Tips and Tricks to Optimize Your C Code for 8-bit AVR Microcontrollers  わたしの現在の開発環境で使うのは、avr-gcc (GCC) 5.4.0です。&amp;ldquo;c99 plus GCC extensions&amp;quot;となるように-std=gnu99をWinAvrベースのMakefileに指定してます。 ちなみに、avr-gcc (GCC) 5.4.0では-std=C99は&amp;quot;ISO C99 standard&amp;quot;完全準拠の はずです。avr-gcc helpの記述に-std=c11、-std=c++11がありISO 2011 C/C++ まで完全準拠が選べるようです。WinAvrのMakefile内に書かれた 「ISO C99準拠が不完全」とのコメントは古いバージョンのavr-gccに基づいている ようですね。確かGCCは4以降では&amp;quot;ISO C99 standard&amp;quot;完全準拠だった気がします。
ちなみに、-std=gnu99では、-std=c11で導入された0b10111011と言った ２進表記での整数定数表記ができます。これが便利です。
8 bitのATmega328Pぐらいにフォーカスして、現在の開発環境下で私なりに検討して、 ある程度の憶測も折り込み、よくまとまっていたAVR035文書の結論を以下に書きなお して見ました。
あまりコードサイズの最適化に頑張り過ぎることは無いと考えています。無理がある 時には、コードを凝るのではなく、所詮趣味でなので実現する機能を削るとか、値段 は知れているので高性能のチップに乗り換えるとかする方が良いのでしょう。実際 Arduino Nanoに載っているATmega328pですらかなり余裕があるので、読みやすくバグ 発生しにくいコーディングを心がけ、デバグしやすいように部分・部分をテストでき るモジュラーな構成を念頭にするもがいい気がします。
そういった意味では、裸のavr-gcc+avr-libcでの開発に拘らずに、Arduino系のインフ ラを利用したコード開発をすれば楽になる面もあるのも事実です。このメモ作成は、 あくまでAVRのコーディングの基礎学習行為の備忘録です。
Hints to Reduce Code Size  Compile with full size optimization.</description>
    </item>
    
    <item>
      <title>ATmega328P (3)</title>
      <link>/jp/2020/03/06/atmega328p-3/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/06/atmega328p-3/</guid>
      <description>前回に続きArduino Uno/Nano に使われている基本のシリアルAVRの ATmega328P を中心としてAVRチップのプログラムの勉強・練習の続きとして、 「AVR Libc Reference Manual」を読み込んでAVR独特の世界をみました。
メモリー PCでのプログラムとはメモリー関係は、少々勝手が違い、IO関係を直接触る上、 メモリー空間も狭いので要注意です。
さらにATmega328Pを含むAVRはﾌﾟﾛｸﾞﾗﾑとﾃﾞｰﾀに対してﾒﾓﾘとﾊﾞｽを分離する ﾊｰﾊﾞｰﾄﾞ構造を使用し、メモリーアドレス空間もそれぞれ別です。 （PCはﾌﾟﾛｸﾞﾗﾑとﾃﾞｰﾀがメモリーアドレス空間を共有するノイマン構造。）
 ﾌﾟﾛｸﾞﾗﾑは不揮発性のフラッシュに格納されます。 ﾃﾞｰﾀは通常の揮発性のSRAMに格納されます。 不揮発データーを格納する別のEEPROMもあります。  ATmega328Pだと：
 ﾌﾗｯｼｭ ﾒﾓﾘ容量 (ﾊﾞｲﾄ) 32K SRAM容量 (ﾊﾞｲﾄ) 2K EEPROM容量 (ﾊﾞｲﾄ) 1K  実際のデーターメモリー領域は以下です。
 ﾚｼﾞｽﾀ ﾌｧｲﾙ (32: 0x00-0x1F)　ーALUの汎用レジスタ I/Oﾚｼﾞｽﾀ (64: 0x20-0x5F) - アセンブラIN/OUT命令は0x20オフセットしたLDS/STS 拡張I/Oﾚｼﾞｽﾀ (160: 0x60-0xFF) 内蔵SRAM (2K: 0x100-0x3FFF)  IN/OUT命令関連のことがよく分からない。どうもAVRの前の世代のマイコン8051の命令 のことのようだ。アセンブラコード移植を意識しているようだ。INTEL系はIOは0x00から 始まる独立アドレス空間なので、アセンブラコードは0x20オフセットした LDS/STS命令に置き換えると言っているようです。
ﾌﾟﾛｸﾞﾗﾑ領域（フラッシュ）へのアクセスには専用のアセンブラコードLPM/SPMがあります。
EEPROM領域へのアクセスは専用のI/Oﾚｼﾞｽﾀ経由で行うようです。
Cコードからは、マクロが準備されているので、ﾌﾟﾛｸﾞﾗﾑ領域たやEEPROM領域へのアクセス には専用マクロ等を使うようだ。詳しくは「ATmega328Pマニュアル」の「ﾃﾞｰﾀ用EEPROMﾒﾓﾘ」や、 「AVR Libc Reference Manual」の「Data in Program Space」や、 avr/eeprom.h や avr/pgmspace.hを参照しましょう。</description>
    </item>
    
    <item>
      <title>ATmega328P (2)</title>
      <link>/jp/2020/03/03/atmega328p-2/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/03/atmega328p-2/</guid>
      <description>Arduino Uno/Nano に使われている基本のシリアルAVRの ATmega328P を中心としてAVRチップのプログラムの練習の続きをしました。
確かにハードとして少々古い感はありますが、５V仕様で安価で入手簡単な開発 ボードがあるのが練習用にいい感じです。
開発環境 クロスコンパイル開発環境は以下でOK（2020/03, Debian stable buster）
 $ sudo apt install gcc-avr avr-libc binutils-avr コードスタイル 以下色々なところからコードを引っ張ってくると、コードスタイルが混じって 見づらくなるし、手動で直すのもばかばかしいのでちょっとコードスタイル関係を 調べました。もともとK&amp;amp;R系のTAB無し2-4スペースインデントの 1TBS なので、色々のスタイルガイドを見て、結局 GOOGLEスタイル に最も共感しました。
今後はPython以外は全言語基本2スペースインデントにします。
VIMのモードライン(C)
// vim: set sts=2 sw=2 ft=c ai si et tw=80: VIMのモードライン(SH)
# vim: set sts=2 sw=2 ft=sh ai si et tw=80: VIMのモードライン(PYTHON)
# vim: set sts=4 sw=4 ft=python ai si et: Cの自動リフォーマットは
 $ clang-format -style=Google -i filename.c SHELLの全文リフォーマットはVIMで(modelineが無い場合は:set syntax=shの後)gg=Gとする。</description>
    </item>
    
    <item>
      <title>AVRISP markII mod-VCC (J)</title>
      <link>/jp/2020/02/27/avrisp-mod-j/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/02/27/avrisp-mod-j/</guid>
      <description>AVRチップのISPプログラマにAVR ISP markIIを使うと、対象AVRチップに別途電源供給 する必要があり、ISP出力のPIN#2にVCCを供給していた以前の TTL-232R-5V を使った自作プロクラマー (英語) を使うより煩雑でした。
そこで、AVR ISP markIIを改造し、ISP出力のPIN#2からVCCを供給出きるように改造し ました。
参考情報 いろんな人が同様の不便を感じ、AVRISP mkIIのUSB から電源を取り、ISP出力のPIN#2 に つなぎVCC電源供給ソースとする改造記事を書いています。以下の改造記事を参考に しました。
 http://www.webx.dk/avrisp-mk2-modding/ (3V/5V selectable, use own fuse, easy output) https://jeelabs.org/2010/04/02/avrisp-mkii-w-5v-power/ (nice input after poly fuse) https://forum.arduino.cc/index.php?topic=125502.0 (half ass fix, Nice pics of wiring, good output point) https://qiita.com/hideyuki/items/71381b741d89878e3e79 (Easy access via TP1, No fuse) http://shiozoku.blogspot.com/2014/02/avr-isp-mkii.html Use switch (No fuse, interesting use reminder) https://electronics.stackexchange.com/questions/286693/can-anything-be-done-about-this-avrisp-mkii-or-is-it-dead (Nice pics of wiring, not the same purpose, fix by bypassing broken DC/DC)　これは本改造とは違う修理改造。  どうもこれらの記事の基板の方が私の持っている基板より配線が太く見やすいです。</description>
    </item>
    
    <item>
      <title>ATmega328P (1)</title>
      <link>/jp/2020/02/21/atmega328p-1/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/02/21/atmega328p-1/</guid>
      <description>AVRチップのISP経由プログラムの練習をします。
ATmega328P は手元にあったブレッドボードに挿せるArduino Nanoのコンパチボードや本物の Uno等を使ってます。
プロクラマー これには、 昔TTL-232R-5V を使った自作プロクラマー を使うのも良いのですが、最近Atmel AVR ISP mkIIをただで人からもらったので それを使います。
詳細な使用説明書（英文）： AVR ISP mkII User Guide
ソフト環境 Debian GNU/Linux buster=stable 環境です。
$ sudo apt install avrdude 接続 AVRISP mkIIのVCCは電源電圧監視用でAVRISP mkII側からは電源供給されませんので、 別途チップへの電源供給ソースが必要！Unoなら12V、NanoならUSBを必ずつなぐこと。
ちなみに、 昔TTL-232R-5V を使った自作プロクラマー は電源電圧供給していたので便利な面がありました。 不便なのでAVRISP mkIIのUSB 電源 と PIN#1 をつなぎ、電源供給ソースとする等の改造をしたい気もしますが 、 これはあとで考えましょう。
ISPケーブルの赤線は１ピン側です。
Uno Nano AVRISP mkII に赤いLEDがつきっぱなしは、ISPコネクター「差し込み忘れ」です。
AVRISP mkII に赤いLEDが点滅は、ISPコネクター「逆差し」です。
Uno $ sudo avrdude -c avrisp2 -P usb -p m328p -v avrdude: Version 6.3-20171130 Copyright (c) 2000-2005 Brian Dean, http://www.</description>
    </item>
    
    <item>
      <title>自作キーボード(1)</title>
      <link>/jp/2020/01/03/cg56-1/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/01/03/cg56-1/</guid>
      <description>以下は基本的に備忘録です。
2016-2017年頃の自作キーボードのハード作成 Arduinoは素人ででもシステム細部まで理解して プログラム出きるので、それなりに面白いんですが、LEDのチカチカやbeep音出し だけではすぐに飽きてしまいました。
そこでキーボードの自作を思いたち、2016年の年末から海外サイトを色々見ました。
 https://geekhack.org/ &amp;ndash; geekhack https://deskthority.net/ &amp;ndash; deskthority  昔から気になっていたことを根本的に解決してくれる ortholinear系のデザインのキーボードがとっても気になり 欲しくなりました。ただPCBからすべて買って組み立てるだけでは面白くない ので、キースイッチの位置精度が要るケース部品のネタ部分だけを3mm MDF板の レーザー加工で2017年2月に発注し入手しました。
作ろうとしたキーボードのデザインは、14C * 4R のortholinear タイプで、 右端のキーを真ん中に移動し、左右の手を通常より2キー離れて置くことを特徴とし ていました。planck等で採用されている片側6列ではなく片側7列とし、左右の手 の間隔を通常より取ったので窮屈でない姿勢で使えるキーボードのデザインにでき たと一人悦に入っていました。
MDFを木工ボンドで接着し組み立て、角をヤスリで落し、段差を紙粘土で埋めて スムーズな形にして、仕上げに塗装したあと、キーを置いてみて気分を楽しんで いました。
まあ、MDFは木材感覚なので、塗装が出来るのと、角を削って落とせるのは メリットでした。キーはプレートマウント状態ですがMDF板は3mm あり1.0-1,5 mm 厚であるべきマウントプレートとして引っかかりある取り付けができませんでした。 それに関してはキースイッチをホットメルト接着剤で裏から留めることで安定させ たので、むしろカンカンという金属板の共鳴音もしなくていい感じでした。
ただその後、他の事に忙しくなり、電子回路を組み上げずに中断していました。 (ケースの高さを抑えかつ強度を確保しようとし過ぎため、ケース内のスペース が少なく配線の作業性が極端に悪かったのも挫けた一因です。)
キーボード関連MCU・ソフト状況 このころいろいろ読んでの、私なりのキーボード関連でのソフトに関する結論を 備忘録で記します。
(昔、この辺は英語でhttps://github.com/osamuaoki/avrdude-friend/wiki に纏めていました。ちょっと加筆して整理しなおしました。今見直すとかなり 参考になります)
まず、USBキーボードに使うMCUはやはりサポートソフト基盤のARDUINOやQMKがあり とっつきが良いATmega32u4に絞りました。読み込んだ資料は以下です。
 atmega32u4 data etc. atmega32u4 データシート LUFA: the Lightweight USB Framework for AVRs Arduino The QMK Configurator &amp;ndash; Open-source keyboard firmware for Atmel AVR and Arm USB families  いくつか気づいたポイントを以下に箇条書きにします。</description>
    </item>
    
  </channel>
</rss>
