<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>programming on Goofing Osamu</title>
    <link>/categories/programming/</link>
    <description>Recent content in programming on Goofing Osamu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>等幅フォント</title>
      <link>/jp/2021/02/23/font-01/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/02/23/font-01/</guid>
      <description>ターミナル環境での等幅フォントをプログラミング入力と日本語入力の両面から 見つめてみました。以下は自分なりの備忘録メモです。
特定ソフトでフォントが汚い 最近のセキュリティーにうるさいソフトは、サンドボックス環境からうまくフォント が拾えなくなり、超低解像度のドットマトリクスフォントが拡大表示されてドン引き することがあります。 https://bugs.debian.org/987948
こんな時には、xdg-desktop-portal-gtkの類のパッケージを導入すると 問題が解決します。
文字の大きさのポイントとは？ 印刷・DTPで細かいことを言わなければ、1ポイントは(約)1/72インチ (0.354mm)の 単位で、フォントセットの中の小文字の&amp;quot;m&amp;quot;の幅をポイントで計ることでフォントの 高さ、つまりフォントのの大きさを示すのに使われます。
スクリーンや印字サイズ PC最初の表示装置のMDAは、白黒文字を文字幅x高さ9x14ピクセルのフォントで 80文字x25行の表示を、720x350の解像度に表示します。文字自体は7x11ピクセル の大きさでした。アナログカラーテレビは、720x480の解像度に表示します。 9x14ピクセルのフォントで最大80文字x34行の表示が出きると言えます。
初期のMacのディスプレーや初期のドットマトリクスプリンターのピクセル間隔は 72 DPIで、初期のFAXは100 DPI、初期のレーザープリンターは300 DPIです。
米国のレター紙(A4に近い)の幅は8.5&amp;quot;なので、余白をとって8&amp;quot;に印字すると すると、パイカサイズのタイプライター風の等幅で10 CPI で印字すると 80文字/行はいります。また詰めた12 CPI で印字すると96文字/行はいります。 そういえば当時の72 DPIのドットマトリクスプリンターでのソースコードの 印刷は8x8 dotsのフォントデーターを、縦横同じすすめかたで10 CPI、 横を詰めた印字で12 CPIとしていました。
私現在のPCの14インチディスプレーはFHDで1920x1080ピクセルです。 どうも160 DPIあります。昔の72 DPI比較で2.2倍の解像度があります
ターミナル環境と等幅フォント 標準のターミナルのサイズは、80文字x24行です。
Xtermだと72mmx48mmで、Gnome-terminalとDejaVu系英文14ポイントの 等幅フォントの組み合わせだと 140mmx86mm位の大きさです。
DejaVu系の英文14ポイントと同じ大きさのスクリーンサイズの ターミナルが、Terminus系の英文16ポイントで得られます。
DejaVu系の等幅フォントに、DejaVuとHackとNotoとMonospaceがあります。 これらに同じフォントサイズの日本語全角文字が入ると、日本語文字が 英文と同じ大きさで行間が余裕ある感じになります。
Terminus系の等幅フォントには、TerminusとUbuntuがあります。これらに 同じフォントサイズの日本語全角文字が入ると、日本語文字が大きくなり 行間が詰まった感じになります。
これを見ると、英語のみならHackでもUbuntuでもフォントサイズ選定 を調整すれば良いようです。ただ、日本語まじりだと、Hackが魅力的 です。HackにはVim用の特殊フォントも入っています。
   Font Point 0O区別 1lI区別 Programing Japanese Overall     Monospace 14 Good Good Good Good Good   DejaVu 14 Good Good Good Good Good   Hack 14 Good Good Excellent Good Excellent   Noto 14 Poor Poor Poor Good Poor   Terminus 16 Good Poor Poor fair Poor   Ubuntu 16 Good Good Excellent fair fair    英文＋プログラムのためにFacebook由来のHackをインストールしターミナル環境で 指定し、UIやターミナル環境内の日本語環境文字はGoogle由来のNoto-CJK系導入で 補うのが良さそうです。</description>
    </item>
    
    <item>
      <title>GITデフォルトブランチの`main`への移行</title>
      <link>/jp/2021/01/27/git-master-main/</link>
      <pubDate>Wed, 27 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/01/27/git-master-main/</guid>
      <description>２１世紀の世情の反映で、 PC の視点から、デフォールトのブランチ名は、masterに代わり、新規のプロジェクトでは mainが使われていきます。
人を不愉快にすることを続けたく無いので、折に触れ過去のプロジェクトでも同様にするべく、 masterからmainへのデフォールトブランチ名を移行するための手順を、備忘録を兼ねたメモ としてここに作成します。
GITHUBサーバーの変更 GithubのWeb interfaceで、Settings -&amp;gt; Branches -&amp;gt; Default branch から 「master」を「main」と変更します。
ローカルのrepoの変更 ローカルブランチ名の変更 次に、GITHUBのWEBインターフェースの吹き出しにある指示手順で、ローカルの repoのブランチ名を状態を確認しながら変更します。
$ git branch -a * master remotes/origin/HEAD -&amp;gt; origin/master remotes/origin/master $ git branch -m master main $ git branch -a * main remotes/origin/HEAD -&amp;gt; origin/master remotes/origin/master $ git status -sb ## main...origin/master トラッキングの移行 さらに、GITHUBのWEBインターフェースの吹き出しにある指示手順で リモートのトラッキングがうまくするための追加の関連設定を 状態を確認しながらします。
$ git fetch origin From github.com:&amp;lt;user_name&amp;gt;/&amp;lt;project_name&amp;gt; * [new branch] main -&amp;gt; origin/main $ git branch -a * main remotes/origin/HEAD -&amp;gt; origin/master remotes/origin/main remotes/origin/master $ git status -sb ## main.</description>
    </item>
    
    <item>
      <title>GITを使うフォークの管理</title>
      <link>/jp/2020/04/02/git-fork/</link>
      <pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/04/02/git-fork/</guid>
      <description>Gitを使う際に、アップストリームのレポの更新に合わせて、 自分がフォークしたレポを如何にスムーズに更新していくかは、 フォークしたレポの開始方法やブランチ名の設定や実行するコマンド 手順に複数のアプローチや複数の対応方法があるだけに、いつも 混乱して悩まされます。
備忘録を兼ねて、アップストリームがGITHUBを使っている 場合を軸にメモを作成します。
GITを使うフォークの管理手順(基本) 簡単のために以下の前提を置きます。（追跡＝tracking）
 他人が管理する、アップストリームのリモートのレポ名を、「upstream」(任意名ですが慣習名)とします。 他人が管理する、アップストリームのリモートのレポ上の「master」ブランチを追跡します。（コピー元） 自分が管理する、フォークしたリモートのレポ名を、「origin」とします。 自分が管理する、フォークしたリモートのレポ上の「master」ブランチに追跡コピーを保管します。（コピー先） アップストリームのレポにあるbranch名やtag名とぶつかるbranch名やtag名を、フォークしたレポに勝手に作らないようにします。  この際の、GITを使うフォークの管理手順は以下です。
  アップストリームのレポのGITHUBウエッブページで「Fork」をクリックして、 自分のアカウントにフォークされたリモートのレポを作成
  フォークされたレポをローカルに「git clone」して、ローカルのレポを作成
 $ git clone git@github.com:my_name/project_name.git ; cd project_name    自分が書き換える開発ブランチ(ここでは「devel」)を作成
 $ git checkout -b devel    ファイルを編集し、開発ブランチにコミット
  アップストリームのリモートのレポをローカルにリモート「upstream」として追加。
 $ git remote add upstream https://github.com/upstream_name/project_name.git    フォークされたレポの「master」ブランチをアップストリームのレポの「master」ブランチに同期
  $ git checkout master ; git fetch -p upstream ; git pull upstream master ; git push origin master  -pは--pruneのショートハンドで、不要なリモート追跡ブランチを削除してくれます。</description>
    </item>
    
  </channel>
</rss>
