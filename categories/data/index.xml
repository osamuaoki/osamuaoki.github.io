<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>data on Goofing Osamu</title>
    <link>/categories/data/</link>
    <description>Recent content in data on Goofing Osamu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/data/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Btrfs入門(2)</title>
      <link>/jp/2021/02/16/btrfs-02/</link>
      <pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/02/16/btrfs-02/</guid>
      <description>半年前に覗いたBtrfs をもう一度見直しました。以下は自分なりの備忘録メモです。
subvolumeの使い方 使用法のガイド のリストのリンク先には興味深いコンテントがあります。 システム管理者ガイド 中の、subvolumeレイアウト の内容は、「使い方」を見詰め直す上で目から鱗でした。
私は単純にFlatなsubvolumeレイアウトを乱用していましたが、 Nestedなsubvolumeレイアウトをうまく使い/etc/fstabを簡素化し、 よく考えて構成したMixedなsubvolumeレイアウトを使うと管理が楽そうです。
この際、Ubuntu風の@home等の 慣習Subvolume命名法 を、Flatなsubvolumeレイアウトなsubvolume名に適用しています。
Root-fsのbtrfs化 RAID関係、圧縮関係、SWAP FILE関係に嵌らない限りbtrfsはかなり安定なようなので ext4にしていたルートファイルシステムもbtrfs化します。
実際にはデュアルブートで別のルートファイルシステムを使いながら、 通常のルートファイルシステムをマウントせずbtrfs-convertでこれを処理します。
ファイルシステムの変換自体はは、 Conversion from Ext3/4 and ReiserFS をトレースしました。
ただこれだけでは、ブート可能なシステムにはなっていません。 ファイルシステムがext4からbtrfsに変更されると同時にデバイスのblkidも 変更されます。例えば、491a357c-822f-4f38-b56e-b998baea81a5 から 9be0d928-5892-4cdd-a647-1e8cce937b2e に変わったとします。
当然ですがこの変更に合わせ当然/etc/fstabに以下のdiffに相当する変更をします。
--- fstab.orig 2021-02-19 14:49:32.768895933 +0900 +++ fstab 2021-02-19 14:49:19.860921576 +0900 @@ -6,6 +6,6 @@ # # &amp;lt;file system&amp;gt; &amp;lt;mount point&amp;gt; &amp;lt;type&amp;gt; &amp;lt;options&amp;gt; &amp;lt;dump&amp;gt; &amp;lt;pass&amp;gt; # / was on /dev/nvme1n1p1 during installation -UUID=491a357c-822f-4f38-b56e-b998baea81a5 / ext4 errors=remount-ro 0 1 +UUID=9be0d928-5892-4cdd-a647-1e8cce937b2e / btrfs subvol=/,defaults 0 1 # /boot/efi was on /dev/nvme0n1p1 during installation 他のパーティションのシステムが設定するgrub2を使っていても、自分のシステムの /boot/grub/grub.</description>
    </item>
    
    <item>
      <title>Btrfs入門(1)</title>
      <link>/jp/2020/05/05/btrfs-01/</link>
      <pubDate>Tue, 05 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/05/05/btrfs-01/</guid>
      <description>先日トライしたGit Annexは不完全燃焼でしたが、これをきっかけに 世代管理・dedup・ファイル圧縮に対応できるというファイルシステムの Btrfs をもう一度見直しました。以下は自分なりの備忘録メモです。
Btrfsをどう使うのか まずBtrfsがどこまで使えて、どういう注意が要るのかを Debianのwiki で確認しました。
2020年5月のLinux goofy 5.4.0-0.bpo.4-amd64でも初心者が 安心して気楽に使うにはまだ制約が多いですね。
 LVMに重ねるのは不安 RAID関連も使うのは不安 quotas/qgroupsは使わないこと Subvolume毎にbtrfs特有オプションでマウントできない制約がある 多くのbtrfs特有オプションは使わないのが無難: nodatacow, 圧縮関連, autodefrag, discard, space_cache=v2 &amp;ldquo;btrfs filesystem defrag&amp;ldquo;はソースSubvolumeにのみ実施。snapshotには実施禁止 スナップショットは12個まで(これでもLVMより状況は良い) ディスクは使用9割を越えないようにする  ここまで調べて、システムファイル/usrやログ記録/var のbtrfs移行は面倒なので、当面は無理せず以下を移行対象に 考えます。
 データーのアーカイブ・バックアップ用の専用ドライブ /homeの専用パーティション  世代管理にはスナップショット機能を濫用しないように程々で 使い、バックアップソフトがバックアップする際にバックアップ メディア上の記録をdedupする配慮をし、ファイル圧縮は当面使 わないのはいい気がしました。
推奨バックアップソフトはborgbackupがDebianのwikiには書か かれています。 確かに人気がある ようです。この他timeshiftやbtrbkやsnapperや btrfsmaintenanceパッケージも使えそうです。
Btrfsを意識したdedupeという視点では jdupesがよく使われている ようです。単純なcp -r ...やrsync ...を、dedupをする jdupes --dedupe ...と組み合わせて使うのに対する、上記 専用ソフトのメリットは気になります&amp;hellip;ただ、jdupesはあまりファイル数が 多くとファイルのオープン数のせいかうまく動かないことがありました。 このへんは後日の課題かな。
Subvolume命名法 Btrfs自体は 特定のSubvolume命名法の慣習を定めていません。
Debianでは特にどうするって言う慣習が無いようです。
ただ、Btrfsを積極的に使うディストリビューションが Subvolume命名法に関して特定の慣習をとっているため そこで開発されているGUIツールがそれに依存してる印象 があります。
 Ubuntu  慣習Subvolume命名法  @ @home   スナップショット: timeshift   OpenSuse  慣習Subvolume命名法 慣習Subvolume命名法(tutorial)  @/ @/home   スナップショット: snapper    最近のDebianでは、borgbackup以外だと timeshiftの人気が出ています。 でもシステムのロールバックにフォーカスしていてユーザーデーターの スナップショットをしたいだけだと意外と使いにくくて止めました。</description>
    </item>
    
    <item>
      <title>Git Annex入門(1)</title>
      <link>/jp/2020/04/22/git-annex-01/</link>
      <pubDate>Wed, 22 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/04/22/git-annex-01/</guid>
      <description>Git関連ツールで、写真等の大きなデーターの分散保存・世代管理をする Git Annexというツールを walkthrough を読みながら学びました。間違っているかもしれませんが、 自分なりに簡単に以下にまとめて見ます。
Git Annexの基本コンセプト Gitはデーターの分散管理では非常に便利ですが、 大きなデーターを直接扱うのが不得意 です。そこで、このGitが不得意な部分のデーターの分散管理を協調的に補完す るのがGit Annexです。
写真等の大きなファイルを含むデーターは、ソースコードなどのテキスト ファイルを含むデーターと違い、ファイル自体がすでに圧縮されていて 保存の際のさらなるデーター圧縮のメリットが少ないことや、世代間の 詳細なデーター差分の検出には大きな労力が必要な割に、詳細な差分は サイズも大きくなりがちでメリットが少ないという特徴があります。
そこで大きなファイルは、Gitの本体で直接扱かわずに、労力とのバランス を考えGitの上に構築したGit Annexで扱うのが望ましいです。Git Annexでは データー保存の効率化対象を単純なファイルの重複保存や世代間のファイル の位置移動に絞ります。この制約の下では、ファイル実体によって決まる 「ユニークな特定パスに保存する」ことで、ファイル実体の効率的な保存 が実現できます。「ユニーク」ということはファイル内容のハッシュ値 等を用いた文字列(Key)で実現します。Git Annexではファイル実体データー (Value)をGit本来のデーター保存インフラとは別の.git/annex/objects/ 以下に書き込み禁止のファイルパーミッションで保存します。
一方、作業ディレクトリーツリー中のファイルがあった場所には Git Annex管理下に保存されたファイルへのシムリンクを置きます。 このシムリンクのデーターサイズは小さいので、本来のGitで問題なく 場所の保存や世代管理ができます。
このままでは他のプログラムによるデーターの編集・更新ができな いので、Git Annexはシムリンクをファイルで置き換え編集可能化する unlock機能と、Git Annexに編集結果を戻すlock機能を提供します。
さらにGit Annexは、「特定パスに保存する」という部分に関して、 「分散保存を管理するインフラを提供する」とすることで、すべての 分散管理レポジトリー内に全ファイルを保持しなくても良い とします。ここは全ファイルを保持する本来のGitレポジトリーと 大きく異なるところです。Git Annexは、分散管理レポジトリー間で それぞれが保存するファイルに関するメタ情報を交換するインフラも 提供します。
Git Annexがチェックアウトした作業ディレクトリーツリー中で、 ローカルに保持していないファイルは、ダングリングシムリンク (宙ぶらりシムリンク)となってしまいます。その際に、保有するメタ 情報に基づき指定範囲のファイル実体をリモートサイトから簡単に オンディマンドでコピーしてくる部分チェックアウト機能や、 作業ディレクトリーツリー中ダングリングシムリンクを簡単に消す 機能もサポートします。
Git Annexによるリモートサイトへのアクセスは抽象化されていて、 単純なファイルシステム経由のアクセスはもちろん、SSH経由のアクセス、 Amazon S3等の各種クラウドへのアクセスが、既成のバックエンドを 利用し、ほぼ同じ手順で簡単に実現出来るようになっています。
Git Annexの注意点 Git Annexは、バックアップファイルの数を自由に設定できたり、保存 ファイルのコピーの代わりに保存ファイルへのハードリンクを利用する ように設定できたり、ユーザーが自由にカスタマイズできる機能が多い 汎用性のあるツールです。それだけに、しっかり基本機能を学ぶことや、 良く各機能の動作を考えて使うことが重要です。</description>
    </item>
    
  </channel>
</rss>
