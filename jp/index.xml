<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>のらくら修(Goofing Osamu 日本語版) on Goofing Osamu</title>
    <link>/jp/</link>
    <description>Recent content in のらくら修(Goofing Osamu 日本語版) on Goofing Osamu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="/jp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PC付属キーマップ改善準備</title>
      <link>/jp/2022/06/03/evdev01/</link>
      <pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/06/03/evdev01/</guid>
      <description>キーボード状況 確かにQMKを使うと自由にキーマップが構成でき、動きの少ない手や指にやさしいタイピングができます。
ただ、PC付属キーキーボードででも、同じようにHOME ROW MOD等ができないかと言う気になります。
interception-toolsを利用し構成する可能性としてはありますが、まだ例が見当たりません。確かにevdevデバイスを通るデーターをフィルター変換で実現するという発想はありです。
ただ、正直分かりにくいので、まず読みやすいPythonのchorded_keymapを見ました。実際にevdevを通るデーターの実態がよく分からなかったので、この中のプログラムをベースにデーターダンプするユーティリティーを作りました。
確かにほぼ同じ機能のコマンドevtestがあるんですが、この経験をしたことで実態がよく分かりました。
この出力は以下です。
 12577.98: MSC SCAN 0xcb / KEY LEFT → / SYN REPORT 0 12577.996: MSC SCAN 0xcb / KEY LEFT ↑ / SYN REPORT 0 12578.431: MSC SCAN 0xcd / KEY RIGHT ↓ / SYN REPORT 0 12578.508: MSC SCAN 0xcd / KEY RIGHT ↑ / SYN REPORT 0 12578.811: MSC SCAN 0xe / KEY BACKSPACE ↓ / SYN REPORT 0 12578.</description>
    </item>
    
    <item>
      <title>可読データー表現 (1)</title>
      <link>/jp/2022/05/29/readable-data01/</link>
      <pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/05/29/readable-data01/</guid>
      <description>設定データーや設定に使うデーターベース等は、規則的な構造で可読化(エディターで閲覧編集)すると、既存ツールが使えて便利です。
可読データー表現法のリスト 振り返って見たら、 可読化されたデーターは結構色々使ってます。
 表データーの表現にはCSVやTSV (JA) TSV (EN) UNIXパスワードファイル(/etc/passwd)等には「:」を使うDSV E-メールデーターで用いるRFC 822 Debianのパッケージ設定で用いるDEB 822 文書やデーターベース等の複雑な構造のデーターの記述にはXML (JA) XML (EN) Gitの設定ファイルはINI (JA) INI (EN) Pythonのパッケージ設定のpyproject.tomlにはTOML (JA) TOML (EN) QMKのファームウエアーのビルド条件記述ではJSON (JA) JSON (EN) intercept (キーボード入力の差替えツール)ではYAML (JA) YAML (EN)  ちょっと混乱してしまいそうです。XMLよりは読みやすく複雑なデーター記述ができながらコンピューター処理にも向いたフォーマットということで、「INI」, 「JSON」, 「TOML」, 「YAML」の４つのデーターシリアル化 (EN) (データーシリアル化 (JA)) 手法を見ていきます。
これらは、人間がエディターで触るのに比較的ハードルが低く、さらに多くのコンピューター言語で読み込み書き出しをするライブラリー化されサポートされているので、非常に使いやすいです。
可読データー表現例 INI 昔のWindowsの設定ファイルのデファクトスタンダード。２レベルまでのサポートという問題や、方言が多い問題がある。 Python標準ライブラリーでサポートれる。
; last modified 1 April 2001 by John Doe [owner] name = John Doe organization = Acme Widgets Inc. [database] ; use IP address in case network name resolution is not working server = 192.</description>
    </item>
    
    <item>
      <title>Digital RGB LED (1)</title>
      <link>/jp/2022/05/21/rgbled1/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/05/21/rgbled1/</guid>
      <description>電子工作の基本の光り物の駆動が、単純なカラーLEDを直接電流駆動するタイプから、MCUが組み込まれてデジタルコントロールの調色機能付のDigital RGB LEDとかNEOPIXEL LED等と呼ばれるLEDをデジタル信号ドライブするように変わってきました。その状況を調べました。
よく使うDigital RGB LEDチップ    LED size VDD data rate signal wire     WS2812B 5mm x 5mm 5V 800 Kbps 1   WS2813 5mm x 5mm 5V 800 Kbps 2   WS2815B 5mm x 5mm 12V 800 Kbps 1   SK6812MINI-E 3.2mm x 2.8mm 5V 800 Kbps 1    すべて800 Kbps で、1.2 us毎に１ビットのクロックで、共通の制御信号でコントロールできます。
WS2812B と その改良型のWS2813の違いは、WS2812B vs WS2813 Addressable RGB LED Strips – How are they different?</description>
    </item>
    
    <item>
      <title>測定関係(1)</title>
      <link>/jp/2022/05/08/measure-1/</link>
      <pubDate>Sun, 08 May 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/05/08/measure-1/</guid>
      <description>以下は基本的に備忘録です。
テスター 抵抗測定・ダイオード検査・導通テスト 古いカード型で簡便なSANWAのSD-420C (LR44 or SR44 ２個使用)と、最近の多機能のMASTECHのMS8221C (AAA or 単3　３個使用)を用いて、デジタルテスターの抵抗測定・ダイオード検査・導通テスト等の実状を確認しました。(以下の表中の括弧内は、端子印加電圧です。)
   機器名 SANWA MASTECH     テスター端子サイズ L=13mm, φ=2.0mm L=15mm, φ=2.0mm   抵抗測定 (Open負荷) 11MΩ (0.216V) 12MΩ (0.239V)   導通ブザー試験 (Open負荷) 1484 and NO BEEP (1.443V) OL and NO BEEP (0.437V)   ダイオード試験 (Open負荷) 導通ブザー兼用 OL (1.296V)   抵抗測定 (1KΩ負荷) 1KΩ (0.113V) 1KΩ (0.166V)   導通ブザー試験 (1KΩ負荷) 345 and BEEP (0.</description>
    </item>
    
    <item>
      <title>QMK (6) -- カスタムキーボード参考情報</title>
      <link>/jp/2022/05/06/kbd-pcb/</link>
      <pubDate>Fri, 06 May 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/05/06/kbd-pcb/</guid>
      <description>汎用設計の14x4のOrtholinearキーボードで試してみて、Mod-Tapを使う、片側6X3_3キー構成ぐらいのスプリットの小さな携帯タイプのカスタムキーマップが小指への負担もなく普通のNotePCのキーボードとの相互移行での違和感もなくいい感じでした。
こうなると、使わないキーをなくした専用のスプリットデザインのキーボードが欲しくなります。
CORNEがほぼ図星のデザインですが、折角なのでPromicroではなくARMの汎用ボード(40PINあるblackpillかPiPico)を使う一から設計製作をしたカスタムキーボードを作りたいと思いました。
当分は取り組まないかもしれないけど、カスタムキーボードをPCBから設計製作する際に参考となる情報をまとめました。
カスタムキーボードまとめサイト  geekhack deskthority r/MechanicalKeyboards: wiki Self-Made Keyboards in Japan - Scrapbox ai03 Design Studio  ai03.com! wiki ai03 Infobase   Keebfol.io: Keyboard &amp;ndash; form: Keebfol.io  Keebfolio: Awesome Mechanical Keyboard   Mechanical Keyboard and where to find them Awesome Split Keyboards  カスタムキーボードFirmware  QMK Firmware &amp;ndash; QMK Firmware Repository (GPL License, AVR or Arm, Lufa or ChibiOS™ based) &amp;ndash; based on TMK firmware  TMK Firmware &amp;ndash; TMK Firmware Repository (GPL License, AVR or Arm, Lufa or ChibiOS™ based)   ZMK Firmware &amp;ndash; ZMK Firmware Repository (MIT License, Arm, Zephyr™ based) KMK Firmware &amp;ndash; Pythonic Mechanical Keyboard Firmware (Arm) Keyberon Firmware &amp;ndash; A rust crate to create a pure rust keyboard firmware (Arm)  カスタムキーボードHW設計・製作 カスタムキーボードPCBの設計 PCBの設計は基本KiCadが使われます。</description>
    </item>
    
    <item>
      <title>QMK (5) -- JOYSTICKサポート</title>
      <link>/jp/2022/04/02/joystick/</link>
      <pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/04/02/joystick/</guid>
      <description>状況 AVRで作ったQMKキーボードでは、タップとホールドを上手く利用した使いやすいキーマップができました。
ARMで作ったQMKキーボードにこれを移植するとともに、追加ハードのアナログJOYSTICKをマウスの機能を提供するデバイスとして有効利用しました。
JOYSTICKデバイスの追加とMCUの機能設定 「JOYSTICK」という言葉に引かれて、よく分からないままマニュアルの「Hardware Features」の「Joystick」をフォローして、ゲーム用のコントローラーとしての「JOYSTICK」デバイスを導入しました。
ここで、ARM系のハードの初期化のカスタマイズ法を学びました。ARMではOS立ち上げコードがチップ機能の初期化をしているようです。マクロを定義することで、コンパイル時に設定が導入されます。ある意味AVRのfuseの感じです。
ChibiOSは、デフォルトのhalconf.hやmcuconf.hを提供しているので、デフォルトでは無効化されたADCを使う等の場合には、設定をオーバーライド変更する必要がありました。 最初に、platforms/chibios/boards/keyboard-config-templates/内のファイルを、プロジェクトフォルダー内にコピーしたファイルをベースに、オーバーライド変更のみを設定します。 デフォルト値は#include_next &amp;quot;... .h&amp;quot;で読み込みます。(この辺の仕組みがが分かる前には、コンパイラーエラーに苦しみました。)
ゲーム用のコントローラーとしての「JOYSTICK」デバイスの動作検証は、Gamepad Tester でしました。この環境での安定動作には、config.hに以下の追加が必要でした。(参考情報源)
#define JOYSTICK_AXES_RESOLUTION 8 #define USB_POLLING_INTERVAL_MS 4 ゲーム用のコントローラーとしてのJOYSTICKデバイスを提供するソース
 cgg56:minijoy  ゲーム用のコントローラーにマウスの機能を提供する設定は、OSの環境設定でできなくはないです。ただこれでは本末転倒です。 ストレートにマウスの機能自体を直接提供すること目的なので、これはここまでにします。
JOYSTICKのハードによるマウス機能の提供 JOYSTICKのハードによるマウス機能の提供には、マニュアルの「Hardware Features」の「Pointing Device」をフォローします。
 cgg56:mini cgg56:micro  Mouse keyよりは快適に動いていますが、ThnkpadのTrackpointが得意でない私には決して使いやすいとは言えない状態でした。
本物のMouseは使いやすい。
反省点 キー入力できない原因を調べたところ、UEW線の被覆熱削除不足による不良が２点、ダイオードの極性方向間違い１点が見つかった。
 UEW線は事前両端カットしてプリ半田して使う (結線不良となりやすい巻付法は使わない) ダイオードの極性の視認チェックは大事 MCU付きのボードをスイッチマトリクスにつなぎ込む前に、結線・ダイオード極性をテスターで電気的にもチェックすべき。  気づいたこと QMKでは意外と多くのハードを利用してマウス機能の提供ができるようです。また、マウスの中身はほぼ似たデバイスのようです。 キーボードだけでなく、ポテンシオメーター、ロータリーエンコーダー、オプティカルセンサー等で作るポインティングデバイスででも遊べそうです。色んな事をみんなしていますね。
ただMCU内臓でI2C等で出力が出てないと、KBへの組み込みには向かない気がする。
ポインティングデバイスのソース 既存の組み込み製品・ジャンクから外すのも一案:
 ダイソーの300円ワイヤレスマウスを分解して回路図と部品表を書いてみた話 (2019-03-14)  「どうせ100均だろ？」って軽い気持ちで分解したら、 ガジェットの進化に驚いた！   トラックボールを作ってみた【試作編】 アナログスティックを使ってcrkbdをマウスとしても使えるようにした話 2 自作トラックポイント1  部品ソース例と価格:
 通常トラックポイント新品製品 ~$50 (工業用はもっと高い)  Mini Panel Mount USB Trackball with Three Buttons by adafruit.</description>
    </item>
    
    <item>
      <title>QMK (4) -- キーマップ改善 (タップとホールドの有効利用)</title>
      <link>/jp/2022/03/15/home-mt/</link>
      <pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/03/15/home-mt/</guid>
      <description>状況 QMKを使うcgc56やcgg56というQMKを利用したキーボード等を使って、色々試して気づいたり考えたことを以下に記します。
 メンタルストレス無く、フィジカルストレスの小さい指の動きが少ないキーマップが欲しい。  親指がカバーするのは、横に並ぶキーが少ないのが望ましい 人差し指は縦の動きで２列カバーする。 他の指は縦１列の動き以外はしない。 「QWERTY」は当分メインのキーマップのベース。 「QWFRTY」はローマ字入力用オプションの検討中キーマップ　（→　結局やめた）。   高速打鍵性自体は私の目指す所では無い。 キーのピッチをきっちり確保するにはNC工具での工作が不可欠。  NCとしてはPCBが安いし、PCBを注文する際に10cm角に収めると更に安い。   統計結果から、記号では「_ 」へのアクセスには要配慮。 14&amp;quot; のノートパソコン(Thinkpad T14 Gen1)に無いキーの優先度は低いと割り切る。  CURSORキーは重要なので、アクセス性は重要で、片手での操作性も重要。 TENキーはそれほど使用上重要では無いが、組み込むなら片手での操作性に配慮重要。 QMKのMOUSEキーはそれほど便利では無いので、組み込む際のアクセス性は重要で無い。    QMKではタップとホールドで出力キーが違う設定できますが、タップの入力文字の連続入力がカチカチ連打だと大変な気がしていました。
実際には、一度タップ直後の再タップ時にホールドするとタップに対応する文字の長押しになるようで、OS側が連打処理してくれ使い勝手良好です。
あまり複雑なキー動作の多重化は混乱を招き使い勝手が悪くなるのですべきでは無いですが、タップとホールドを上手に使えば悪くない感じです。
キーマップ 最初にトライしたレイヤー移動とモード変更機能のすべてを親指のキーに任せるアプローチには無理がありました。
キーマップ osamu そこで30%キーボード系のferrisのキーマップをヒントにし、「基本的に使う部分」を、左5x3_2キーと右5x3_2キーと限定し、親指はレイヤー移動のみにしたキーマップを組むのがフィジカルストレス低減によさそうです。
 │***│ Q │ W │ E │ R │ T │***│***│ Y │ U │ I │ O │ P │***│ │***│lsA│lcS│laD│lgF│raG│***│***│raH│lgJ│laK│lcL│ls;│***│ │***│ Z │ X │ C │ V │ B │***│***│ N │ M │ , │ .</description>
    </item>
    
    <item>
      <title>STM32F411CE (3)</title>
      <link>/jp/2022/03/06/blackpill-3/</link>
      <pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/03/06/blackpill-3/</guid>
      <description>dfu-utilは、最近、Debianででも最新の 0.11-1 が使えるようになりました。dfu-suffix等もちゃんとmanpageが付いてます。
プログラムの導入はDFUでできるめどが立ったのですが、DFUベースで動くシステムもう少しで遊んでみます。（STLINKは興味はあるけど後回しにします。）
DFUのこつ 「DFUに入りにくい」などと言うことをNETで散見します。（チップを温めるなどという「おまじない」も日本語のどこかで見ました。）
確かに、無頓着にBOOT0とNRSTのPUSHスイッチを同時押し・同時離しでDFUに入ろうとすると上手くいかないことがありました。
でも、以下の手順をとれば、確実にDFUに入れます。
 まず、BOOT0を押す(1sこの状態を保つ) 併せて、NRSTも押す(1sこの状態を保つ) NRSTを離す(この時もBOOT0は押したまま) 3ステップの1s後、BOOT0を離す  DFUデバイスのrealtimeの確認は、今風にjournalctl -fコマンドです。(昔はsudo dmsg -w)。
繋がったDFUデバイスの詳細状況は、dfu-util -lで確認します。
電源投入後すぐだと、一度以下のようなエラーでDFUに入れないことがありました。
usb 4-2: new full-speed USB device number 4 using xhci_hcd usb 4-2: device descriptor read/64, error -71 usb 4-2: device descriptor read/64, error -71 usb 4-2: new full-speed USB device number 5 using xhci_hcd usb 4-2: device descriptor read/64, error -71 usb 4-2: device descriptor read/64, error -71 usb usb4-port2: attempt power cycle usb 4-2: new full-speed USB device number 6 using xhci_hcd usb 4-2: Device not responding to setup address.</description>
    </item>
    
    <item>
      <title>STM32F411CE (2)</title>
      <link>/jp/2022/02/22/blackpill-2/</link>
      <pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/02/22/blackpill-2/</guid>
      <description>STM32F411CEが載っているblackpillの導入記録の続きです。
HID BOOTLOADER の復元準備 前記の方法でQMKをDFUで内蔵フラッシュメモリーの0x800 0000から導入すると上書きされてしまいます。書き換えできるメモリーの最後にbootloaderを置くAVRと異なり、ARM系のSTM32Fはフラッシュの最初の0x800 0000にBootloader等を置かれているからです。
STM32F103のような、ROM化されたUSB対応bootloaderが無いMCUの場合にはHID BOOTLOADERが必要ですが、STM32F411等はROMがDFUをサポートしてUSB経由のファームウエアー書き換えに対応しているので、HID BOOTLOADERは必須要素技術ではありません。ここは、後学のため元のHID BOOTLOADERの復元法を記します。(元々はA12ピン問題で悩んでいた際の学習ノートです。)
最初に入っていたHID Bootloaderは、ベンダーの WeActTC の技術情報サイトを覗き入手します。
 https://github.com/WeActTC  HEXファイルやバイナリーのホストプログラムとともに、元ネタサイト情報もありました。
 https://github.com/Serasidis/STM32_HID_Bootloader  ARDUINO作成のスケッチのアップロードは、WeAct_HID_Flash-CLIで単純にBINファイルを書いているので、ARDUINO系のシステムでSTM32F103と共通のファームウエアーを作成し使用するには、HID_Bootloaderも良いかもしれません。
アドレス ベンダーの WeActTCの技術情報サイトから落としたGIT repo中の情報によると、HID Bootloaderの APP forwarding addressは0x8004000だそうです。 STM32F103と違いSTM32F411はフラッシュの書き換え単位が16KBあるので、これだけのスペース空けています。
   ROM Addr     0x8000000 Bootloader   16KB   0x8004000 APP   &amp;hellip;..   END    つまり元々ボード上のMCUに書き込まれていたのHID Bootloaderには0x800 0400 に読み込まれて実行されるように作成したファームウエアーが必要です。
QMKは通常0x800 0000 に書き込み実行するファームウエアーを作成するので、QMKファームウエアーの導入にHID Bootloaderは使えません。
HEXファイル WeActが提供するプロプライエタリーのHEXファイルは以下:
 HID Bootloader: MiniSTM32F4x1/Soft/WeAct_HID_FW_Bootloader/Bootloader/WeAct_HID_Bootloader_F4x1.</description>
    </item>
    
    <item>
      <title>QMK (3) -- QWFRTY配列</title>
      <link>/jp/2022/02/14/qwfrty/</link>
      <pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/02/14/qwfrty/</guid>
      <description>背景 キーボードによるストレス低減のためのMCUを使ったIOTの初等プロジェクトとして、QMKを使うcgc56というQMKを利用したキーボードを作りました。
ストレスのソースと削減指針は２つあり、そのバランスが重要です。
 フィジカルストレス削減には、できるだけ指の移動に無理が無いのが望ましいと考えます。 メンタルストレス削減には、できるだけ標準キーボードと変わらないのが望ましいと考えます。  このcgc56は元々は中指を伸ばして「E」を叩きづらいという個人的課題のフィジカルストレス削減のキーボードプロジェクトでした。
これだけなら「E」と「F」のスワップで済ますのも良いのですが、それだけでは勿体ないので、苦労しない範囲でDVRAKの交互打鍵に近づけられないかと考えた妥協点案が上記の写真の「QWFRTY配列」です。これはあくまでQMKを利用した自作キーボードの最適化キー配列実験で、私の日常生活はQWERTY配列です。
 cgc56 (4x14) は planck (4x12) よりはキーの数が多い。  普通のLaptop PCのキーボードに近いキー配列が可能です。 一体型ですが両手間隔がとれ猫背にならずに使えます。   2つあるメインのFnキーキャップの前面角が面取り加工されてい、親指の触覚で手の位置が確認できます。  実は、DVORAK・COLMAK・WORKMAN・COLEMAK-DH等の既存の「エルゴノミックキーマップ」でフィジカルストレス削減する方策は、私にとっていずれも学習障壁（メンタルストレス）が高すぎました。(これらの有名配置だと、VIエディターでのカーソール移動も難しくなってしまいます)。
この状況下で思いついた「QWFRTY配列」は使ってみてフィジカルストレス削減手法として意外とおもしろいので、ここに要点等をメモしておきます。
QWFRTY配列 「QWFRTY配列」は、11個のキーだけが標準の「QWERTY配列」から移動された配列です。
名前は、１文字違いでややこしいですが、「QWFRTY配列」としました。キーは位置の要点を抜き出すと以下です。
 LEFT HAND RIGHT HAND │ Q │ W │_F_│ R │ T │ │ Y │_D_│_K_│_G_│ P │ │ A │_I_│_U_│_E_│_O_│ │_S_│_H_│_J_│ L │ ; │ │ Z │ X │ C │ V │ B │ │ N │ M │ , │ .</description>
    </item>
    
    <item>
      <title>STM32F411CE (1)</title>
      <link>/jp/2022/02/07/blackpill-1/</link>
      <pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/02/07/blackpill-1/</guid>
      <description>基本のSTM32F系の安価だけど、純正STMチップ(同等品でない)が載っていそうな 小型のデモボードとして、WeActのblackpillをAliexpressの正規ショップ から購入しました。STM32F411CEが載っています。
 WeActのデバイス情報 https://github.com/WeActTC/MiniSTM32F4x1  PCB回路要点    IC PIN 機能 動作     7 NRST RESET SW, PUSH=0 , NORMAL=1   44 BOOT0 BOOT SW, PUSH=1, NORMAL=0   20 PB2 / BOOT1 NORMAL=0 (pull down res.)   10 PA0 / WKUP1 USER KEY, NORMAL=1, PUSH=0   2 PC13 / BLUE LED, LED_ON=0    STM32のメモリー  0x0000 0000 - 0x0007 FFFF (REMAPされる) &amp;ndash; The code area  通常 BOOT0は押されていないので: Flash memoryをさしている  つまりユーザー作成のFirmware実行   BOOT0 pushed: System memory (BOOT0 pushed)  CU内臓のBOOTLOADERの実行, STM32F411の場合はUSB経由のDFUもサポート     0x2000 0000 - 0x2002 0000 SRAM1 (128 KB) &amp;ndash; The data area 0x0800 0000 - 0x0807 FFFF Flash memory Flash memory (512KB) 0x1FFF 0000 - 0x1FFF 77FF System memory (32MB)  起動  the CPU fetches the top-of-stack value from address 0x0000 0000, the CPU starts code execution from the boot memory starting from 0x0000 0004.</description>
    </item>
    
    <item>
      <title>配線と半田付け</title>
      <link>/jp/2022/01/28/wire-1/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/01/28/wire-1/</guid>
      <description>典型的配線材料 趣味の工作の基本配線材料を整理しました。
 基板上低電圧信号用 UEW電線 AWG-32 (0.2mm)　単線、5V 以下 基板上通常信号用 ジュンフロンETFE電線 AWG-30 単線 (0.26mm) 多色準備　Wirewrapにも使える 基板上電源線 TA (錫メッキ線) 0.5mm　単線 (AWG 24(0.51mm) 単線 の LAN cable使用線の流用) 基板間配線（コネクター使用圧着)はAWG 24(0.5mm)相当のヨリせん (多色準備?) 基板間配線（pin header経由直付け)はAWG 30(0.5mm)単線のWIREWRAP 基板間配線（PCB直付け)はAWG 30(0.5mm)単線のTHハンダ付け 電源: 15A current -&amp;gt; 0.8 mm2 -&amp;gt; 1mm -&amp;gt; AWG18のヨリせん  配線方法諸説  錫メッキ耐熱樹脂被覆導線をワイヤーストリッパー＋ハンダ付けで利用する配線方法  電子工作のヒント &amp;ndash; ジュンフロンAWG30使用(2000以前のページ?)、実用性高い &amp;ndash; 今の私の方法 愛用の工具と材料 (2007年) &amp;ndash; OK industries AWG30銀メッキKynar使用 &amp;ndash; 究極の実施例 &amp;ndash; 真似できない Circuit Board Prototyping Tips and Tricks Vector board, Dead bug, &amp;hellip; (2016) How to Solder properly || Through-hole (THT) &amp;amp; Surface-mount (SMD) Perfboard, solder wick (2017)   UEW線・錫メッキ線を使うELM-CHANの究極の配線方法 (1997-&amp;gt;2014年)  信号線: ポリウレタン銅線(φ0.</description>
    </item>
    
    <item>
      <title>MCU (AVRとARM) の周囲状況と比較</title>
      <link>/jp/2022/01/19/mcu-comp/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/01/19/mcu-comp/</guid>
      <description>MCUとそのプロトボード状況 AliExpressやbangoodを初めとした中華コマースサイトは便利なんだけど、魑魅魍魎の棲家ですね。
中華コマースサイトで売られる安いボードは実際に使っているMCUまで違う状況と知り驚いてます。ICチップパッケージの刻印が本家で中身が違うなら贋チップ使用というのでしょうが、堂々とICチップパッケージの刻印にコンパチ品が書いてあったり、高性能だったりするようです。
またPCB基板が同じPIN配置の製品ですが、回路配置利用権を考えると、ちょっとヤバいかもしれないので要注意。（ただ、小型のプロトボードはPINアウトを揃えると、必然的に本家のボードに似た回路配置になってしまう。PINアウトが同じこと自体は規制されないので判断は難しい。実際に入手し本家PCBと並べて詳細に比べないとコンパチPCB品が回路配置権を侵害したかどうかは判断できないので、入手前には無理。）
とりあえずネットで見つけた関連情報のリンクをリストしておきます。
 Teensy  https://www.pjrc.com/teensy/counterfeit.html &amp;ndash; Aliexpress販売のTeensyは本物でない。  本物のTeensy 2.0++は製造終了で欠品中(2022/Jan.)。AT90USB1286使用のコンパクトなボードはコンパチ品しか手に入らない状況。     ARM系(blue/blackpill)  STM32-base のboard紹介によると、安いblue/blackpillは贋STMチップが多いとのこと。 https://hackaday.com/2020/10/22/stm32-clones-the-good-the-bad-and-the-ugly/ https://www.cnx-software.com/2019/02/10/cs32-mcu-stm32-clone-bluepill-board/ https://www.cnx-software.com/2019/12/24/stm32-black-pill-board-features-stm32f4-cortex-m4-mcu-optional-spi-flash/ https://www.cnx-software.com/2020/03/22/how-to-detect-stm32-fakes/ https://github.com/WeActTC/MiniSTM32F4x1/blob/master/README.md WeActの製品情報  怪しいパチ物(PCBパターンが同等？旧タイプ？)を売っているVENDERの実名リストがある（Aliexpressでよく見るTZTは怪しいらしい！）     STM32F103コンパチチップ状況  GD32F103: https://www.gigadevice.com/products/microcontrollers/gd32/arm-cortex-m3/ &amp;ndash; Datasheet https://www.usenix.org/system/files/woot20-paper-obermaier.pdf &amp;ndash; 本物とコンパチチップのセキュリティー解析比較(USENIX, 2020以降) 評価 https://www.cnx-software.com/2015/12/21/gigadevice-gd32-is-a-faster-software-and-pin-to-pin-stm32-compatible-cortex-m3-mcu/ 評価 https://www.instructables.com/Alternative-to-STM32F103C8T6-by-GigaDevice/ コメント https://eetimes.itmedia.co.jp/ee/articles/2001/28/news032_2.html   ATmega328P (Arduino Unoのチップ)  贋物は不良症状としてスリープモードの電流が多いこともあるようです。流石に調査がしっかりしているとおもったら、部品の調査検定会社のYOUTUBE情報でした。   DS18B20 Temperature Sensors  https://www.cnx-software.com/2020/07/13/fake-ds18b20-temperature-sensors-counterfeit-clones/   FTDI FT232RLの贋物騒動 &amp;ndash; Windowsの正規品ドライバーで壊れる  https://hackaday.</description>
    </item>
    
    <item>
      <title>QMK (2)</title>
      <link>/jp/2022/01/18/qmk-2/</link>
      <pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/01/18/qmk-2/</guid>
      <description>手始めに、QMK : キーマップのカスタマイズ (2018年頃)も参考に、できるだけ今風の(2022年)qmkコマンドを使って、１つのキーのカスタムキーボードを作ります。
対象ハードはatmega32u4が載ったTeensy2.0の中華コンパチボードです。本物のTeensy2.0でないのでatmel-dfuがBOOTLOADERだったはずです。ただ、BOOTLOADERはISP接続で小さな(512 bytes)HIDデバイスのnanoBoot (w/LED)に書き換えています。
 .word 0x03EB // idVendor -- Vendor ID (Atmel VID, from LUFA) .word 0x2067 // idProduct -- Product ID (HID Class Bootloader PID, from LUFA) これってqmk-hidと同じIDです。ファームウエアーのサイズはqmk-hidの4KB(?)よりnanoBootは小さいメリットがあります。
ファームエアーのアップロードプロトコルは同じ　halfkeyコンパチのID違いなので、指定は同じにして良い気がします。
作成デバイスはメディアキーのMUTE１つのデバイスです。
テンプレート作成  $ qmk cd $ gitk --all ... (最新の「master」ブランチのリリースが0.15.15と確認) $ git checkout 0.15.15 $ git checkout -b osamu1 $ qmk new-keyboard Ψ Generating a new QMK keyboard directory Keyboard Name: one Keyboard Type: 1.</description>
    </item>
    
    <item>
      <title>QMK (1)</title>
      <link>/jp/2022/01/14/qmk-1/</link>
      <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/jp/2022/01/14/qmk-1/</guid>
      <description>どうもカスタムキーボードのフリーのファームウエアとしてはQMKが一番充実しているのですが、久しぶりにのぞくと2017年2月のころとかなり様子が変わっているようにも見えます。特に気になるのはconfig.jsonの存在です。
とにかくカバーするキーボードハードウエアー数が大きくなってきたので、リファクターして共通部分の重複回避を試みている様です。
QMKのドキュメントもかなり更新されています。
復習を兼ねてコード・ドキュメントを追います。
qmkコマンドとビルド 最近、QMK Toolboxをpip経由で導入する、非プログラマーにも使いやすいマルチプラットフォーム対応のUIを目指したpythonで書かれたthin wrapperのqmkというCLIコマンドが提供されています。
qmkコマンドは、作業環境設定や、firmwareのビルド、はたまた種々の関連処理プログラムの提供や起動に用いるようです。でもビルドされるCコードのコアの部分はあまり変わっていないようです。
まず、Install Using pipに従い環境をDebian 11 (Bullseye/testing)に導入しました。
qmk setupの自動設定でチェックアウトされるレポは、git submoduleを使っていて、レボがうまくまとめられています。レポ内にグラフィクスなどを保存しなくなり、キーマッピングもキーボード間で共用可能なものをまとめたり、マッピングだけのユーザーカスタム化情報がメインのkeyboads/以下のソースツリー外に置けるようです。ただソースを理解するのが少々手間となりました。
qmkは、初期導入時に~/.bashrcを変更し、shellの環境変数QMK_HOMEにチェックアウトしたレポの場所を保存したようです。（手動でしたのかどうか忘れました）
qmkのコマンドの説明はQMK CLI Commandsにあります。
どうもビルドは公式にはqmkコマンドを使うようになっているそうですが、その背後で何がどうなっているのかが気になります。
レポを見ると、791b9cc652 (&amp;ldquo;remove all makefiles from keyboard directories&amp;rdquo;, 2017-09-27)で昔ビルドに使っていた各キーボード毎の独立のMakefileが無くなっています。だから、ビルドの実体はrootにあるMakefileがしているはずです。いかんせんrootのMakefileは複雑なので閉口でした。
今残っているrootにあるMakefileにからむのかがwebにあるエンドユーザー向けの説明ではよく分からないので、試しにrootにあるMakefileを無効なターゲットで動かすと以下のメッセージが出ます。
$ make help QMK Firmware 0.15.12 make: *** No rule to make target &amp;#39;help&amp;#39;. Stop. | | QMK&amp;#39;s make format is: | make keyboard_folder:keymap_folder[:target] | | Where `keyboard_folder` is the path to the keyboard relative to | `qmk_firmware/keyboards/`, and `keymap_folder` is the name of the | keymap folder under that board&amp;#39;s `keymaps/` directory.</description>
    </item>
    
    <item>
      <title>ATmega32u4 (4) --AT90USB1286も含めて...</title>
      <link>/jp/2021/12/11/atmega32u4-4/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/12/11/atmega32u4-4/</guid>
      <description>基本のUSB AVRのATmega32u4と AT90USB1286 を中心としたAVRチップに関して、ブートローダー関係を、１年半２年ぶりに見直し書きます。
開発環境 ATmega328P (2)の開発環境を再現すればOKです。
USB系のAVRで、変数名等の細かなところにとにかく疑問が出れば、/usr/lib/avr/include/以下を見れば分かります。。
 /usr/lib/avr/include/avr/iom32u4.h &amp;ndash; teensy2.0 (ATmega32u4) /usr/lib/avr/include/avr/iousb1286.h &amp;ndash; teensy2.0++ (AT90USB1286)  FUSEビットのSET FUSEビットは、プログラム設定されると「0」で、プログラム解除されると「1」です。 不揮発メモリーのリセット状態が1なので、こうされている理屈は分かるのですが、通常のPIN信号電位等と逆で混乱します。
 プログラム設定(条件合致) = 対応ビット 0 プログラム設定(条件不合致) = 対応ビット 1  電源投入時ちゃんとファームウエアーが立ち上がるには、BOOTRSTは1にして application reset (address 0x0000)としないといけません。 (BOOTRSTは0だと Reset vector = boot loader resetとなり、メモリー末尾に行きます。)
FUSEの設定変更(JTAG) FUSEの設定変更は当然ですが要注意です。　よく考えずにJTAGをENABLEしたら、一部GPIOピンが動作しなくなって驚きました。
BOOT MODE (HWBE)のこと USB系のAVRの起動の基本確認事項として、BOOTのモードの状況を確認します。
ARDUINO LEONARDO やTEENSY系の基板のPE2 (ALE,/HWBE)では、1K等で接地されています。だから、実際に出会うボードのリセットボタンが押された際のBOOT挙動は以下です。
 通常PE2は接地電位なので、リセットを押したらHWBEヒューズがON(0)にされてると、ブートローダーの起動となる。 強引にPE2(ALE)をVCCに繋いだ状態で、リセットだとHWBEヒューズ設定によらず、アプリファームが起動する。(その間1Kに電気が5mAも流れますが。) HWBEがOFF(1)の場合、PE2によらず常にアプリファームが起動する。  ISP接続によるMCUのプログラミング AVR-ISP II等を使うと、ブートローダーも何もない状態ででもISP接続でMCUに直接プログラム書き込みができます。
 http://ww1.microchip.com/downloads/en/Appnotes/doc2568.pdf http://ww1.microchip.com/downloads/en/AppNotes/doc1644.pdf  ブートローダーの書き換えにはこれを使います
確実ですが、接続が面倒でICピンを占領するので、定常的使用にはむきません。
TEENSY系でのISP接続でのブートローダー書き込み接続 TEENSY系はARDUINOのようなISP接続でのブートローダー書き込み専用コネクターはついていません． だから、AVRISP2から出ているケーブル端の以下のようなコネクター穴に、PIN-PINのアダプターを差し込みます。 (私の場合クリップケーブル端のデュポンコネクターの横穴はフラットケーブルの方向に向けてつけている。写真参照) 接続はこのPIN-PINのアダプター経由で連結したクリップをボード端の穴へ繋ぐのが簡単のようです。</description>
    </item>
    
    <item>
      <title>Python環境とパッケージ作成</title>
      <link>/jp/2021/06/17/python-package/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/06/17/python-package/</guid>
      <description>Pythonで書かれたプログラム管理は、Debian供給のdebパッケージを使う限り、 普通にAPTで管理するだけなので簡単です。
一方、ソースからの導入などを考え出すと、Pythonのモジュール管理の変遷もあり結構ややこしいので、ここで復習します。
Python のパッケージの導入 Debian供給のdebパッケージ以外からの導入の基本ルールは、 OS環境をコンタミしないようにするのが賢明です。
具体的には、ソースからバイナリパッケージのwheelを作成しての導入の場合や、 外部レポジトリーのPython Package Indexからの導入の場合のともに、 仮想環境(7) の手法を使って導入という流れです。
Python関連のPython Packaging User Guideからリンクされた サイトの公式マニュアルにある、python3 -m pip install --upgrade pip setuptools wheel 等のコマンドを、安定版システムで漫然と通常のシェルから実行すると最新版が導入され、 その後のシェル環境からはこちらが優先され実行されるようになり、 干渉するかもしれないので要注意です。
pipをpipxとすれば良いだけですが、気をつけたいところです．
Python のパッケージの作成 また、モジュールパッケージを導入する際に、昔の基本の distutils を使おうとすると、最近はマニュアルにLegacy等と書いてあるので 不安になります。当時は、python3 setup.py install ...等として いきなりターゲットディレクトリーに書き込みモジュールパッケージを導入 していました。
現在はPython Packaging Authorityのルールに合致させ Python Package Indexにアップロード出きるようにするには、 distutilsではなく 殆ど変わらない使い勝手のsetuptoolsと 合わせてwheelを用い、setup.pyを作成すれば、 python3 setup.py bdist_wheel等としてwheel形式でのモジュールパッケージ 出力が難なくできます。
wheel形式でのモジュールパッケージはpipで 扱えます。
ちなみに、distributeは、 setuptoolsにマージされたとか、 setuptoolsが以前使っていた easy_install は非推薦ツールとなり、wheel形式でモジュールパッケージを作成し pipでモジュールパッケージを導入するようになったという、 過去の経緯を理解しないといろんな手法の立ち位置がわかりにくいです。
wheel形式とは、その実体はクロスプラットフォームで一番使われる アーカイブ形式のZIPファイルです。
さらに最近のPEP517に準拠させるには、 別のパッケージ作成インフラを使おうとしないなら、単に PEP518準拠の、 以下のpyproject.tomlを加えれば充分です。
[build-system] requires = [ &amp;#34;setuptools&amp;gt;=42&amp;#34;, &amp;#34;wheel&amp;#34; ] build-backend = &amp;#34;setuptools.</description>
    </item>
    
    <item>
      <title>仮想環境(7)</title>
      <link>/jp/2021/06/17/virt-07/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/06/17/virt-07/</guid>
      <description>コンテナ技術を用いる仮想環境利用の考察 コンテナ技術を用いる仮想環境は、外部から導入するバイナリーを実行する 際のリスク低減とメインのシステムの環境コンタミを防ぐのには悪くないので しょう。そういった意味でtesting環境では安定しないオフィス関係のデスク トップアプリの安定版最新バージョンの導入や、Debianがまだ提供していない アップストリームの最新バージョンのアプリ導入に使うのはありがも知れません。
 AppImage Flatpack Snapcraft  ただ、単にパッケージ開発やビルド環境のためだけならLXC仮想環境をLXCの CLIから用いるのは面倒です。
最初の、仮想環境(1) の内容を見直してsbuild/schrootを経由した単純なchroot環境を使うようになり 益々そう感じます。
chrootにせよLXCにせよKernel以外のシステム全体のコピーを各環境毎に確保する ので重いことは否めません。
Python: venv + pip (manual) Debianが提供しなくなったgripを、 PyPIからのPythonのモジュールとしてpipで導入すると、 すでにシステムに導入済みのPythonのモジュールまで、sudoしなかったので システムレベルでの/usr/local/の中への変更は無く、ユーザー環境の ~/.local/の中への変更のみとはいえ、そこに最新版を依存関係で導入したり するのが気になっていました。さすがにこれだけのためにchrootやコンテナ環境 を作るのは重いのでPython環境だけを仮想化しました。
gripをPython環境だけを仮想化して導入した ので、以下に例示します。
$ pip list --user いま、ユーザー環境へのpipによるパッケージ導入はありません。
$ cd ~/bin $ python3 -m venv venv $ cd venv $ source venv/bin/activate (venv) $ pip install grip Collecting grip Using cached grip-4.5.2-py3-none-any.whl Collecting requests&amp;gt;=2.4.1 Using cached requests-2.25.1-py2.py3-none-any.whl (61 kB) Collecting path-and-address&amp;gt;=2.0.1 Using cached path_and_address-2.</description>
    </item>
    
    <item>
      <title>等幅フォント</title>
      <link>/jp/2021/02/23/font-01/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/02/23/font-01/</guid>
      <description>ターミナル環境での等幅フォントをプログラミング入力と日本語入力の両面から 見つめてみました。以下は自分なりの備忘録メモです。
特定ソフトでフォントが汚い 最近のセキュリティーにうるさいソフトは、サンドボックス環境からうまくフォント が拾えなくなり、超低解像度のドットマトリクスフォントが拡大表示されてドン引き することがあります。 https://bugs.debian.org/987948
こんな時には、xdg-desktop-portal-gtkの類のパッケージを導入すると 問題が解決します。
文字の大きさのポイントとは？ 印刷・DTPで細かいことを言わなければ、1ポイントは(約)1/72インチ (0.354mm)の 単位で、フォントセットの中の小文字の&amp;quot;m&amp;quot;の幅をポイントで計ることでフォントの 高さ、つまりフォントのの大きさを示すのに使われます。
スクリーンや印字サイズ PC最初の表示装置のMDAは、白黒文字を文字幅x高さ9x14ピクセルのフォントで 80文字x25行の表示を、720x350の解像度に表示します。文字自体は7x11ピクセル の大きさでした。アナログカラーテレビは、720x480の解像度に表示します。 9x14ピクセルのフォントで最大80文字x34行の表示が出きると言えます。
初期のMacのディスプレーや初期のドットマトリクスプリンターのピクセル間隔は 72 DPIで、初期のFAXは100 DPI、初期のレーザープリンターは300 DPIです。
米国のレター紙(A4に近い)の幅は8.5&amp;quot;なので、余白をとって8&amp;quot;に印字すると すると、パイカサイズのタイプライター風の等幅で10 CPI で印字すると 80文字/行はいります。また詰めた12 CPI で印字すると96文字/行はいります。 そういえば当時の72 DPIのドットマトリクスプリンターでのソースコードの 印刷は8x8 dotsのフォントデーターを、縦横同じすすめかたで10 CPI、 横を詰めた印字で12 CPIとしていました。
私現在のPCの14インチディスプレーはFHDで1920x1080ピクセルです。 どうも160 DPIあります。昔の72 DPI比較で2.2倍の解像度があります
ターミナル環境と等幅フォント 標準のターミナルのサイズは、80文字x24行です。
Xtermだと72mmx48mmで、Gnome-terminalとDejaVu系英文14ポイントの 等幅フォントの組み合わせだと 140mmx86mm位の大きさです。
DejaVu系の英文14ポイントと同じ大きさのスクリーンサイズの ターミナルが、Terminus系の英文16ポイントで得られます。
DejaVu系の等幅フォントに、DejaVuとHackとNotoとMonospaceがあります。 これらに同じフォントサイズの日本語全角文字が入ると、日本語文字が 英文と同じ大きさで行間が余裕ある感じになります。
Terminus系の等幅フォントには、TerminusとUbuntuがあります。これらに 同じフォントサイズの日本語全角文字が入ると、日本語文字が大きくなり 行間が詰まった感じになります。
これを見ると、英語のみならHackでもUbuntuでもフォントサイズ選定 を調整すれば良いようです。ただ、日本語まじりだと、Hackが魅力的 です。HackにはVim用の特殊フォントも入っています。
   Font Point 0O区別 1lI区別 Programing Japanese Overall     Monospace 14 Good Good Good Good Good   DejaVu 14 Good Good Good Good Good   Hack 14 Good Good Excellent Good Excellent   Noto 14 Poor Poor Poor Good Poor   Terminus 16 Good Poor Poor fair Poor   Ubuntu 16 Good Good Excellent fair fair    英文＋プログラムのためにFacebook由来のHackをインストールしターミナル環境で 指定し、UIやターミナル環境内の日本語環境文字はGoogle由来のNoto-CJK系導入で 補うのが良さそうです。</description>
    </item>
    
    <item>
      <title>Btrfs入門(2)</title>
      <link>/jp/2021/02/16/btrfs-02/</link>
      <pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/02/16/btrfs-02/</guid>
      <description>半年前に覗いたBtrfs をもう一度見直しました。以下は自分なりの備忘録メモです。
subvolumeの使い方 使用法のガイド のリストのリンク先には興味深いコンテントがあります。 システム管理者ガイド 中の、subvolumeレイアウト の内容は、「使い方」を見詰め直す上で目から鱗でした。
私は単純にFlatなsubvolumeレイアウトを乱用していましたが、 Nestedなsubvolumeレイアウトをうまく使い/etc/fstabを簡素化し、 よく考えて構成したMixedなsubvolumeレイアウトを使うと管理が楽そうです。
この際、Ubuntu風の@home等の 慣習Subvolume命名法 を、Flatなsubvolumeレイアウトなsubvolume名に適用しています。
Root-fsのbtrfs化 RAID関係、圧縮関係、SWAP FILE関係に嵌らない限りbtrfsはかなり安定なようなので ext4にしていたルートファイルシステムも含めてbtrfs化をめざします。
btrfs化の全体手順 btrfs化を確実にするために、練習を兼ねてサブ環境で移行を確認した上でメイン環境を移行します。
 EFIパーティションを共有した2つ以上別のパーティションを使う2つ以上のLinuxが立ち上げられるマルチブート環境を作成します。（EFIパーティションはWindowsとも共有） サブのLinux環境のbtrfs化  メインのLinux環境を立ち上げ、サブのLinux環境をbtrfs化します。（btrfs-convertで処理） サブのLinux環境の/etc/fstabや/boot/grub/grub.cfg内を編集し、サブのLinux環境関連の設定をbtrfsに変更し、新しく付与されたUUIDに更新します。 メインのLinux環境の/boot/grub/grub.cfg内を編集し、サブのLinux環境関連の設定をbtrfsに変更し、新しく付与されたUUIDに更新します。(sudo dpkg-reconfigure grub-efi-amd64とするのでもいいはず) サブのLinux環境を立ち上げ、正常動作を確認します。 サブのLinux環境を立ち上げ、メインのLinux環境をbtrfs化します。（この時点では、subvol=/にメインのシステムあり）   サブのLinux環境のsubvol=@への移動  サブのLinux環境のスナップショットを subvol=@に作成します。 メインのLinux環境を立ち上げ、サブのLinux環境のsubvol=/を/mntにマウントし、後述のバグ回避策の処理を行います。 subvol=@に移動したサブのLinux環境を立ち上げ、動作を確認します。 念のためsudo dpkg-reconfigure grub-efi-amd64とし、起動確認を確認します。   メインのLinux環境に関して、上記同様の、Linux環境のbtrfs化＋Linux環境のsubvol=@への移動を行います。 メインのLinux環境に関して、timeshiftを使えるようにsubvol=@homeを追加します。  Linux環境のbtrfs化 btrfs-convertによるファイルシステムの変換自体は、 Conversion from Ext3/4 and ReiserFS をトレースしました。
ファイルシステムの変換だけでは、ブート可能なシステムにはなっていません。 ファイルシステムがext4からbtrfsに変更されると同時にデバイスのblkidも 変更されます。例えば、491a357c-822f-4f38-b56e-b998baea81a5 から 9be0d928-5892-4cdd-a647-1e8cce937b2e に変わったとします。
当然ですがこの変更に合わせ当然/etc/fstabに以下のdiffに相当する変更をします。
--- fstab.orig 2021-02-19 14:49:32.768895933 +0900 +++ fstab 2021-02-19 14:49:19.</description>
    </item>
    
    <item>
      <title>仮想環境(6)</title>
      <link>/jp/2021/02/13/virt-06/</link>
      <pubDate>Sat, 13 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/02/13/virt-06/</guid>
      <description>Linux Namespaces の雰囲気が分かったところで、非特権ユーザー権限から立ち 上げられたLXC仮想環境を作ってみます。
非特権LXC実行環境整備 LXC (1:4.0.6-1) をBulleseye環境で/usr/share/doc/lxc/README.Debianの &amp;ldquo;Unprivileged containers&amp;quot;に従って設定していきます。(2021/02)
まずKERNELがunprivileged user namespacesを有効にしていることを確認します。
$ sudo uname -a Linux **** 5.10.0-3-amd64 #1 SMP Debian 5.10.13-1 (2021-02-06) x86_64 GNU/Linux $ sudo sysctl kernel.unprivileged_userns_clone kernel.unprivileged_userns_clone = 1 ユーザーアカウント設定の/etc/subuidと/etc/subgidはすでに設定されていました。 これらは親システムのUIDやGIDからLXCコンテナ内から見えるUIDやGIDへの対応関係定義 しています。
ネットワーク設定は以下を実行：
$ NAME=$(id -un) $ sudo sh -c &amp;#34;echo $NAME veth lxcbr0 10 &amp;gt;&amp;gt; /etc/lxc/lxc-usernet さらに、~/.config/lxc/default.confのユーザー設定を/etc/subuidと /etc/subgidに合わせて以下でします。
$ mkdir -p ~/.config/lxc $ cat &amp;gt;~/.config/lxc/default.conf &amp;lt;&amp;lt; EOF lxc.include = /etc/lxc/default.conf lxc.idmap = u 0 100000 65536 lxc.</description>
    </item>
    
    <item>
      <title>仮想環境(5)</title>
      <link>/jp/2021/02/12/virt-05/</link>
      <pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/02/12/virt-05/</guid>
      <description>引き続き非特権ユーザー権限から立ち上げられたLXC仮想環境を実現するための 技術背景を学ぶために、Linux Namespaces 周辺に着目します。
User Namespaces Linux Namespacesの中でuser_namespaces(7)で説明されている User NamespacesはユーザーIDやグループID等のセキュリティー関連の識別子 と属性(credentials(7)参照。本来は、資格、信任状の意味の単語)を 分離します。属性とは具体的に言うとルートディレクトリーや、 キー(keyrings(7)参照。本来は、鍵の意味の単語)や、 ケーパビリティ(capabilities(7)参照。本来は能力・資質の意味の単語) 等です。
このUser Namespacesにより、Namespacesの中ではあたかも特権ユーザーとして 振る舞いながら、Namespacesの外では通常の非特権ユーザー権限を保持するプロセスを 実現することができます。この際のユーザーIDの対応関係が/proc/[pid]/uid_map ファイルに記されています。(グループIDの場合は/proc/[pid]/gid_map)
たとえばコンテナ環境外のシェルプロセスのuid_map以下です。
$ cat /proc/$$/uid_map 0 0 4294967295 これは、最初の0 が現amespacesのユーザーID、次の0 が(実在しない)親Namespaces のユーザーID に対応し、(2^32)-1の4294967295が対応関係範囲長となります。 対応関係範囲長を2^32としないのは故意で2^32番目のユーザーID 4294967295 は「ユーザーID無し」の返り値となっているからだそうです。
/proc/[pid]/uid_mapは、newuidmap(1)で設定できます。その際に 許容されるユーザーIDが/etc/subuidに羅列し規定されています。
LXC 4.0の非特権ユーザーのコンテナ起動は、/usr/share/doc/lxc/README.Debianに 詳しく書かれています。この様な現在のシステムでは、各コンテナ環境では 16ビットユーザーIDの 0 - 65536＝(2^16)-2 を使っているようです。
$ id -nu osamu $ cat /etc/subuid osamu:100000:65536 ここの100000は見通しが良いように大きい目になっていますが、65538以上の 適当なオフセット値ですね。このようなオフセット値を各コンテナ毎ずらせば 確かにコンテナを安全に隔離できますね。
ちなみに、chroot(2)システムコールが設定するプロセスごとの ルートディレクトリーは/proc/[pid]/rootからのシムリンクとして 記録されています。これを使えば、コンテナ毎に違うルートファイルシステム 内容のシステムを作成できます。
オーバーレイマウントやバインドマウント等のカーネル機能も効率的な仮想環境 構成に使えます。
なんとなく、コンテナ環境の仮想化が収まっている全体感というか様子が、 ちょっと見えてきました。
shadow-utils Linux Namespaces関連のnewuidmap(1)等のコマンドは、 Shadow が提供するshadow-utilsのソース中にあり、Debianでは uidmapバイナリーパッケージの中で提供されています。</description>
    </item>
    
    <item>
      <title>仮想環境(4)</title>
      <link>/jp/2021/02/06/virt-04/</link>
      <pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/02/06/virt-04/</guid>
      <description>特権ユーザーでのシステムとしてのLXC仮想環境はほぼchrootと変わらないので それほど違和感はありませんでした。
この次に非特権ユーザー権限から立ち上げられたLXC仮想環境を実現するための 技術背景を学ぶために、ここはひとまずLXCのコマンドを離れ Linux Namespaces 周辺に着目します。Linux Namespaces は伝統的なUNIXの範疇を越えているので、 Linuxがカーネルレベルでどこがどう拡張されているのかを2021年2月の時点の Debian Bulleseye/testing pre-11 release環境で確認していきます。
Linux Namespaces どうもLXCも含めた各種コンテナ環境は2002年以降拡充されてきた LinuxのNamespaces というカーネルの機能を使っていることがキーだと分かりました。
とりあえず、以下の関連マンページに目を通しました。
 namespaces(7): LinuxのNamespaces全体の説明 cgroup_namespaces(7): Cgroup root directory ipc_namespaces(7): System V IPC, POSIX message queues network_namespaces(7): Network devices, stacks, ports, etc. mount_namespaces(7): Mount points pid_namespaces(7): Process IDs time_namespaces(7): Boot and monotonic clocks user_namespaces(7): User and group IDs uts_namespaces(7): Hostname and NIS domain name  Cgroup Namespaces Linux Namespacesの中でcgroup_namespaces(7)は、/proc/[pid]/cgroup と /proc/[pid]/mountinfo から見えるプロセスのcgroups (コントロールグループ) の見え方を仮想化します。各種コンテナ環境を可能にする仮想化技術の中心的な要素 としておもしろそうだったので、自分なりに追加の状況確認をしながらtraceしたの ですがマンページの通りには行きませんでした。</description>
    </item>
    
    <item>
      <title>サウンド環境</title>
      <link>/jp/2021/02/04/pulseaudio/</link>
      <pubDate>Thu, 04 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/02/04/pulseaudio/</guid>
      <description>GNOME Desktop環境周辺の最近のサウンド環境関連の状況を確認してみました。
サウンド環境 サウンド環境が色々あって住み分けが分かりにくいのでまとめてみました。
 Open Sound System (OSS): UNIX用のサウンドカードドライバー  デバイス名: /dev/dsp, /dev/mixer (本来のOSSは古い。実際はALSA環境がOSSエミュレーションとして提供するデバイスを利用)   Advanced Linux Sound Architecture (ALSA): 現在のLinuxカーネル中のサウンドカードドライバーとユーティリティー  デバイス名: /dev/snd/* asoundrc 中のデバイス名: hw:0,0, hw1,0   PulseAudio: 多機能の汎用のネットワーク機能付きのサウンドサーバー  ALSAシステム上で稼働 systemdとの相性良好 (同一アップストリーム)   JACK Audio Connection Kit (JACK): 低レイテンシーのプロ仕様ネットワーク機能付きのサウンドサーバー  (サウンドはJACK無しでも使用可)   PipeWire is a server and user space API to deal with multimedia pipeline  (今後注目)    PulseAudioとJACKの住み分けは、PulseAudio や systemd のアップストリームの Lennart Poettering による Pid Eins: PulseAudio and Jack の比較記事を読むと状況がよく分かります。PulseAudio自体は、2008年ごろは色々問題があったのは LPC: Linux audio: it&amp;rsquo;s a messから分かるし、また最近も 2017, 2018, 2019 には音量のデフォルト設定問題があった様ですが、 ユーザー設定で回避 する様です。</description>
    </item>
    
    <item>
      <title>仮想環境(3)</title>
      <link>/jp/2021/01/28/virt-03/</link>
      <pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/01/28/virt-03/</guid>
      <description>引き続きchrootの強化版のようなLXCを使っての仮想環境作成を特権ユーザーが 作成する簡単なケースを深堀りします。
LXC仮想環境の停止 仮想環境のカスタマイズした起動をするためには、作成し起動した仮想環境のSTATEを STOPPED(停止)に確実にします。
$ sudo lxc-stop -n sid $ sudo lxc-ls -f NAME STATE AUTOSTART GROUPS IPV4 IPV6 UNPRIVILEGED buster STOPPED 0 - - - false sid STOPPED 0 - - - false LXC仮想環境とのデーター共有起動 仮想環境のカスタマイズした起動時に、設定変数を指定することで、ホスト側の /home/fish/srcを仮想環境内の/home/fishとしてアクセスできるように共有化 された仮想環境として起動できます。この仮想環境環境にユーザーアカウントに ログインするまでの手順は以下です。
$ sudo lxc-start -n sid \ -s &amp;#34;lxc.mount.entry=/home/fish/src home/fish none bind 0 0&amp;#34; $ sudo lxc-attach -n sid root@sid:/# login sid login: fish Password: ... fish@sid:~$ ここで仮想環境内のホームディレクトリーで見えるのは/home/fish/srcと同一デバイス上の ファイルだけです。(再帰的マウントはされません。)
このLXC仮想環境内でパッケージビルドなどをすれば綺麗な環境ででき、さらにその結果に ホスト側から直接アクセスできます。</description>
    </item>
    
    <item>
      <title>GITデフォルトブランチの`main`への移行</title>
      <link>/jp/2021/01/27/git-master-main/</link>
      <pubDate>Wed, 27 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/01/27/git-master-main/</guid>
      <description>２１世紀の世情の反映で、 PC の視点から、デフォールトのブランチ名は、masterに代わり、新規のプロジェクトでは mainが使われていきます。
人を不愉快にすることを続けたく無いので、折に触れ過去のプロジェクトでも同様にするべく、 masterからmainへのデフォールトブランチ名を移行するための手順を、備忘録を兼ねたメモ としてここに作成します。
GITHUBサーバーの変更 GithubのWeb interfaceで、Settings -&amp;gt; Branches -&amp;gt; Default branch から 「master」を「main」と変更します。
ローカルのrepoの変更 ローカルブランチ名の変更 次に、GITHUBのWEBインターフェースの吹き出しにある指示手順で、ローカルの repoのブランチ名を状態を確認しながら変更します。
$ git branch -a * master remotes/origin/HEAD -&amp;gt; origin/master remotes/origin/master $ git branch -m master main $ git branch -a * main remotes/origin/HEAD -&amp;gt; origin/master remotes/origin/master $ git status -sb ## main...origin/master トラッキングの移行 さらに、GITHUBのWEBインターフェースの吹き出しにある指示手順で リモートのトラッキングがうまくするための追加の関連設定を 状態を確認しながらします。
$ git fetch origin From github.com:&amp;lt;user_name&amp;gt;/&amp;lt;project_name&amp;gt; * [new branch] main -&amp;gt; origin/main $ git branch -a * main remotes/origin/HEAD -&amp;gt; origin/master remotes/origin/main remotes/origin/master $ git status -sb ## main.</description>
    </item>
    
    <item>
      <title>仮想環境(2)</title>
      <link>/jp/2021/01/08/virt-02/</link>
      <pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/jp/2021/01/08/virt-02/</guid>
      <description>chrootを使ってのデバグ用のsid仮想環境作成をpbuilder/cowbuilderでと言うのは 少々強引です。とはいえ直接chrootやmountコマンドで仮想環境作成というのも 面倒です。
そこで、chrootの強化版のような環境設定インフラが整ったLXCを使ってのパッケージ 作成やデバグ用や古い環境下での動作確認等に使え、システムの立ち上げや動作が 軽快な仮想環境作成を試みます。(KVMは悪くは無いですが、重いことは否めません)
ちなみに、DebianではLXDはまだパッケージされていないので、ここでは裸の LXC 4.0 のインフラを使います。
WEB上のLXCの情報は古い1.0や2.0の情報とか、新規のUIを提供するLXDの情報が多い ので、bulleseyeベースの現行testing環境で基本操作を行って詳細の確認しています。
Debianの最新のLXC環境を確認するには、まず/usr/share/doc/lxc/README.Debianを しっかり読む必要があります。ここに書かれたユーザー権限で実行されるコンテナ (unprivileged containers) 関連の手動設定は重要です。
まずは、簡単なROOT権限で実行されるコンテナ中心に始めます。
LXC仮想環境作成 LXCを使ってのパッケージ作成やデバグ用等に使うsid環境の仮想環境作成を試みます。
 $ sudo lxc-create -n sid -t debian -- -r sid もし、ミラーが不調なら、安定そうなUSミラーを使います。
 $ sudo lxc-create -n sid -t debian -- -r sid --mirror=http://ftp.us.debian.org 意外と簡単です。これで、/var/lib/lxc/sid/が作成されます。この中に、sidコンテナ 環境のファイルシステムがrootfsディレクトリー以下に、またそのコンテナ環境の設定 ファイルconfig が作成されています。
コンテナ環境のファイルシステム:
 # root@goofy:/var/lib/lxc/sid# tree -L 2 -F . ├── config └── rootfs/ ├── bin -&amp;gt; usr/bin/ ├── boot/ ├── dev/ ├── etc/ ├── home/ ├── lib -&amp;gt; usr/lib/ ├── lib32 -&amp;gt; usr/lib32/ ├── lib64 -&amp;gt; usr/lib64/ ├── libx32 -&amp;gt; usr/libx32/ ├── media/ ├── mnt/ ├── opt/ ├── proc/ ├── root/ ├── run/ ├── sbin -&amp;gt; usr/sbin/ ├── selinux/ ├── srv/ ├── sys/ ├── tmp/ ├── usr/ └── var/ コンテナ環境の設定ファイルconfig:</description>
    </item>
    
    <item>
      <title>仮想環境(1)</title>
      <link>/jp/2020/12/13/virt-01/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/12/13/virt-01/</guid>
      <description>2021-06-17:　sbuild使用に更新
開発環境の基本 開発環境は、できるだけ安定しているほうがストレスが少ないです。editorを 使いメールやウエッブページを読むだけならstable環境が使えればそれでも いいのですが、新しいハードウエアー (Thinkpad T14, AMD Ryzen 5 PRO 4650U with Radeon Graphics)だとグラフィクスドライバーの問題があるので testing ぐらいは必要です。でも歳々アップデートすると不安定になったりして面倒です。
パッケージ作成環境 以前は、pbuilder/cowbuilder を使って仮想化されたchroot環境を使っていましたが、 最近はschroot/sbuildででも確実に sid/unstable 環境を確保でき、色々便利なので 乗り換えました。
開発環境をsidにしなくても確実にパッケージが正しいsid環境で作成できます。
 英語：Sbuildインフラ参照.  これで、sbuild コマンド実行で、 sid/unstable 環境で確実にパッケージが作成できます。
デバグ用の仮想環境作成 (chroot) デバグ操作用のsid/unstable 環境の作業用のシェル環境が、現在のHOME環境のままで快適に使えるので便利です。
 英語：Schrootインフラ参照.  devsコマンドで、作業用の chroot 環境のベースとなるソースchroot 環境 にパッケージの 追加や削除や更新ができるシェルプロンプトへ、現在のHOME環境のままで移動できます。
devxコマンドで、gitkが使えるX環境へのアクセスできる作業用の使い捨てできる作業用の chroot 環境に、現在のHOME環境のままで移動できます。</description>
    </item>
    
    <item>
      <title>Rescue media(1)</title>
      <link>/jp/2020/05/30/rescue-01/</link>
      <pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/05/30/rescue-01/</guid>
      <description>Boot loader &amp;ndash; Super Grub2 UEFIとかMBRとかある昨今のシステムに対応する、Rescue mediaを探しました。
Grubのレスキューイメージもありますが、これを直接操るのは結構大変 と思っていたら、 Super Grub2 と言う便利なものがあることに気づきました。
Super Grub2はUEFIとかMBRの設定が壊れたシステムを自動調査してくれ 起動してくれるのみならず、DebianやUbuntuのLIVE ISOイメージを DOSのFATファイルシステムのメディアに複数書き込むだけで、これらを 選択起動できるようにしてくれる優れものです。
よく分かっていませんが、ディスクの入れ替えやインストーをして、その後 元のディスクに戻した際にUEFIでブートしなくなったことを経験しました。 そんな際にSuper Grub2だと素直に起動しました。この際に、ただ起動後 update-grubとしただけでは、起動設定更新がうまく行かなかったことが ありました。こんな時にはまず以下を実行しました。
$ sudo dpkg-reconfigure grub-efi-amd64 これだとNVRAM variablesの更新他いろいろするようです。さらにBIOSの ブートの優先順位をさわることも有効でした。(古いMBなのでBIOSが賢くない 気がしました。)
Linux Live image for Super Grub2 実際にSuper Grub2に用意した8GBのUSBキーでは、レスキュー用のLinuxの Live imageとして以下のISOイメージを入れました。
 Rescatux boot-repair Debian live install image  こららがあると思うだけで、UEFIとMBRの両方のシステム対応なので 安心感があります。
ここで使うISOイメージですが、Debianの標準のインストール用の ISOイメージは、上記が用いるGrub2のループマウントでは 使えないようです。
Debianのインストール用の最小ISOイメージ Debianの標準のインストール用のISOイメージは、全イメージを 生のUSBキーに直接cpかddで書いたものを準備する必要があります。 １つ古い小さなUSBキーに書いて手元に置いています。
このDebianの標準のインストール用のISOイメージですが、 わたしは視力があり音声サポートがいらないので、D-Iが作っている mini.iso を使っています。46MBと極端に小さいので便利です。
インストール後の追加作業 実際のインストールの際には、キーファイル(GNUPG/SSHデーター)に加え チェックアウトされた
 VIMの設定集 ローカルのshell script集  他のファイルの入った小型バックアップのUSBキーを準備すると効率的に 進められます。</description>
    </item>
    
    <item>
      <title>Btrfs入門(1)</title>
      <link>/jp/2020/05/05/btrfs-01/</link>
      <pubDate>Tue, 05 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/05/05/btrfs-01/</guid>
      <description>先日トライしたGit Annexは不完全燃焼でしたが、これをきっかけに 世代管理・dedup・ファイル圧縮に対応できるというファイルシステムの Btrfs をもう一度見直しました。以下は自分なりの備忘録メモです。
Btrfsをどう使うのか まずBtrfsがどこまで使えて、どういう注意が要るのかを Debianのwiki で確認しました。
2020年5月のLinux goofy 5.4.0-0.bpo.4-amd64でも初心者が 安心して気楽に使うにはまだ制約が多いですね。
 LVMに重ねるのは不安 RAID関連も使うのは不安 quotas/qgroupsは使わないこと Subvolume毎にbtrfs特有オプションでマウントできない制約がある 多くのbtrfs特有オプションは使わないのが無難: nodatacow, 圧縮関連, autodefrag, discard, space_cache=v2 &amp;ldquo;btrfs filesystem defrag&amp;ldquo;はソースSubvolumeにのみ実施。snapshotには実施禁止 スナップショットは12個まで(これでもLVMより状況は良い) ディスクは使用9割を越えないようにする  ここまで調べて、システムファイル/usrやログ記録/var のbtrfs移行は面倒なので、当面は無理せず以下を移行対象に 考えます。
 データーのアーカイブ・バックアップ用の専用ドライブ /homeの専用パーティション  世代管理にはスナップショット機能を濫用しないように程々で 使い、バックアップソフトがバックアップする際にバックアップ メディア上の記録をdedupする配慮をし、ファイル圧縮は当面使 わないのはいい気がしました。
推奨バックアップソフトはborgbackupがDebianのwikiには書か かれています。 確かに人気がある ようです。この他timeshiftやbtrbkやsnapperや btrfsmaintenanceパッケージも使えそうです。
Btrfsを意識したdedupeという視点では jdupesがよく使われている ようです。単純なcp -r ...やrsync ...を、dedupをする jdupes --dedupe ...と組み合わせて使うのに対する、上記 専用ソフトのメリットは気になります&amp;hellip;ただ、jdupesはあまりファイル数が 多くとファイルのオープン数のせいかうまく動かないことがありました。 このへんは後日の課題かな。
Subvolume命名法 Btrfs自体は 特定のSubvolume命名法の慣習を定めていません。
Debianでは特にどうするって言う慣習が無いようです。
ただ、Btrfsを積極的に使うディストリビューションが Subvolume命名法に関して特定の慣習をとっているため そこで開発されているGUIツールがそれに依存してる印象 があります。
 Ubuntu  慣習Subvolume命名法  @ @home   スナップショット: timeshift   OpenSuse  慣習Subvolume命名法 慣習Subvolume命名法(tutorial)  @/ @/home   スナップショット: snapper    最近のDebianでは、borgbackup以外だと timeshiftの人気が出ています。 でもシステムのロールバックにフォーカスしていてユーザーデーターの スナップショットをしたいだけだと意外と使いにくくて止めました。</description>
    </item>
    
    <item>
      <title>Git Annex入門(1)</title>
      <link>/jp/2020/04/22/git-annex-01/</link>
      <pubDate>Wed, 22 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/04/22/git-annex-01/</guid>
      <description>正直なところ、今は Git Annexを 使っていません。rsync と btrfs の 組み合わせでバックアップしています。(2021/07/07)
 Git関連ツールで、写真等の大きなデーターの分散保存・世代管理をする Git Annexというツールを walkthrough を読みながら学びました。間違っているかもしれませんが、 自分なりに簡単に以下にまとめて見ます。
Git Annexの基本コンセプト Gitはデーターの分散管理では非常に便利ですが、 大きなデーターを直接扱うのが不得意 です。そこで、このGitが不得意な部分のデーターの分散管理を協調的に補完す るのがGit Annexです。
写真等の大きなファイルを含むデーターは、ソースコードなどのテキスト ファイルを含むデーターと違い、ファイル自体がすでに圧縮されていて 保存の際のさらなるデーター圧縮のメリットが少ないことや、世代間の 詳細なデーター差分の検出には大きな労力が必要な割に、詳細な差分は サイズも大きくなりがちでメリットが少ないという特徴があります。
そこで大きなファイルは、Gitの本体で直接扱かわずに、労力とのバランス を考えGitの上に構築したGit Annexで扱うのが望ましいです。Git Annexでは データー保存の効率化対象を単純なファイルの重複保存や世代間のファイル の位置移動に絞ります。この制約の下では、ファイル実体によって決まる 「ユニークな特定パスに保存する」ことで、ファイル実体の効率的な保存 が実現できます。「ユニーク」ということはファイル内容のハッシュ値 等を用いた文字列(Key)で実現します。Git Annexではファイル実体データー (Value)をGit本来のデーター保存インフラとは別の.git/annex/objects/ 以下に書き込み禁止のファイルパーミッションで保存します。
一方、作業ディレクトリーツリー中のファイルがあった場所には Git Annex管理下に保存されたファイルへのシムリンクを置きます。 このシムリンクのデーターサイズは小さいので、本来のGitで問題なく 場所の保存や世代管理ができます。
このままでは他のプログラムによるデーターの編集・更新ができな いので、Git Annexはシムリンクをファイルで置き換え編集可能化する unlock機能と、Git Annexに編集結果を戻すlock機能を提供します。
さらにGit Annexは、「特定パスに保存する」という部分に関して、 「分散保存を管理するインフラを提供する」とすることで、すべての 分散管理レポジトリー内に全ファイルを保持しなくても良い とします。ここは全ファイルを保持する本来のGitレポジトリーと 大きく異なるところです。Git Annexは、分散管理レポジトリー間で それぞれが保存するファイルに関するメタ情報を交換するインフラも 提供します。
Git Annexがチェックアウトした作業ディレクトリーツリー中で、 ローカルに保持していないファイルは、ダングリングシムリンク (宙ぶらりシムリンク)となってしまいます。その際に、保有するメタ 情報に基づき指定範囲のファイル実体をリモートサイトから簡単に オンディマンドでコピーしてくる部分チェックアウト機能や、 作業ディレクトリーツリー中ダングリングシムリンクを簡単に消す 機能もサポートします。
Git Annexによるリモートサイトへのアクセスは抽象化されていて、 単純なファイルシステム経由のアクセスはもちろん、SSH経由のアクセス、 Amazon S3等の各種クラウドへのアクセスが、既成のバックエンドを 利用し、ほぼ同じ手順で簡単に実現出来るようになっています。</description>
    </item>
    
    <item>
      <title>ATmega32u4 (3)</title>
      <link>/jp/2020/04/05/atmega32u4-3/</link>
      <pubDate>Sun, 05 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/04/05/atmega32u4-3/</guid>
      <description>今回も引き続き基本のUSB AVRの ATmega32u4 を中心としたAVRチップに関して、Teensy 2.0の中華コンパチ評価ボード を用いて練習します。
割り込みVector表 アセンブラーとC言語で書かれたBootloaderからの起動を追いかけて、 電源投入(POR)やリセットボタンを押された際のMCU処理の流れが気に なりました。アセンブラーは、しっかり割り込みVector表があるのが 分かるのですが、C言語で書かれた場合特に明示的なテーブルが無いの にどうして割り込みVector表がプログラムされてくるのかがよく見え ませんでした。
C言語では割り込みルーチンはISR(&amp;lt;割り込みVector名&amp;gt;)という形で 関数として定義します。割り込みVector表自体は明示的にプログラムしません。
後で考えれば「なーんだ」でしたが、リンカーがコンパイル時に、 このISR()関数定義にあわせて、コンパイラー提供のスタートアップ コード中の確保されている割り込みVector表に、割り込みルーチンの アドレスを入れ完成するらしいと分かりました。確かによく見ると 割り込みVector表は、blink.lstに見当たらないが、blink.lss等 に定義されています。
ISP接続とUSB接続の干渉問題 ISP接続でブートローダーを導入した上で、その動作をUSB経由接続でアプリケーション のファームウエアーを導入して試そうとして見た際に、何度やっても電源投入で ファームウエアーが立ち上がらず、ブートローダーが立ち上がって悩みました。
問題はISP接続のリセット線が繋がっていたことです。通電時でも0.5Vぐらいの端子の ため、リセット線がPULL-DOWNされてリセットボタンが押されたのと同じ状態になって MCUが停止していたようです。さらにややこしくしたのは改造ISPではプログラマーの 電圧検知端子がプログラマーのVCCに繋がっているので、評価ボードからプログラマー に電気が供給され、電圧の高いリセットボタンが離された状態に一時的にでもなるのか 単にMCUの実行が止まるのではなくちゃんとリセットがかかり、ブートローダーが 立ち上がるようです。
少なくとも、プログラマーからのISP接続のリセット線だけは評価ボードから抜く 必要があります。まあ、VCCに繋がっている線も念のため抜くべきです。これらが ATmega32u4 (2) ISP接続 の「（使わないときは抜く）」という表記の背景です。
LED点滅 (Lチカ) まず、ブートローダー動作確認用にATmega32u4用に単純なLEDの点滅（通称Lチカ） というアプリケーションのファームウエアーのコードをPD0:PD7ピン全部を点滅 させるように書き換えます。こうすることでLチカが、このアプリケーションに よるのか、それともブートローダー中のコードによるのかを、外部LED挙動で 簡単に判別できるようになります。
#define F_CPU 16000000UL #include &amp;lt;avr/io.h&amp;gt; #include &amp;lt;util/delay.h&amp;gt; int main(void) { CLKPR = 0x80; CLKPR = 0; // set cpu prescale to 1 (disable CKDIV8) DDRD = 0xff; while (1) { PORTD = 0xff; _delay_ms(100); // 0.</description>
    </item>
    
    <item>
      <title>GITを使うフォークの管理</title>
      <link>/jp/2020/04/02/git-fork/</link>
      <pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/04/02/git-fork/</guid>
      <description>Gitを使う際に、アップストリームのレポの更新に合わせて、 自分がフォークしたレポを如何にスムーズに更新していくかは、 フォークしたレポの開始方法やブランチ名の設定や実行するコマンド 手順に複数のアプローチや複数の対応方法があるだけに、いつも 混乱して悩まされます。
備忘録を兼ねて、アップストリームがGITHUBを使っている 場合を軸にメモを作成します。
世の流れで、デフォルトブランチ名に「master」ではなく「main」等を使うことが最近増えています。その場合は適宜以下も読み替えてください。
GITを使うフォークの管理手順(基本) 簡単のために以下の前提を置きます。（追跡＝tracking）
 他人が管理する、アップストリームのリモートのレポ名を、「upstream」(任意名ですが慣習名)とします。 他人が管理する、アップストリームのリモートのレポ上の「master」ブランチを追跡します。（コピー元） 自分が管理する、フォークしたリモートのレポ名を、「origin」とします。 自分が管理する、フォークしたリモートのレポ上の「master」ブランチに追跡コピーを保管します。（コピー先） アップストリームのレポにあるbranch名やtag名とぶつかるbranch名やtag名を、フォークしたレポに勝手に作らないようにします。  この際の、GITを使うフォークの管理手順は以下です。
  アップストリームのレポのGITHUBウエッブページで「Fork」をクリックして、 自分のアカウントにフォークされたリモートのレポを作成
  フォークされたレポをローカルに「git clone」して、ローカルのレポを作成
 $ git clone git@github.com:my_name/project_name.git ; cd project_name    自分が書き換える開発ブランチ(ここでは「devel」)を作成
 $ git checkout -b devel    ファイルを編集し、開発ブランチにコミット
  アップストリームのリモートのレポをローカルにリモート「upstream」として追加。
 $ git remote add upstream https://github.com/upstream_name/project_name.git    フォークされたレポの「master」ブランチをアップストリームのレポの「master」ブランチに同期
  $ git checkout master ; git fetch -p upstream ; git pull upstream master ; git push origin master  -pは--pruneのショートハンドで、不要なリモート追跡ブランチを削除してくれます。</description>
    </item>
    
    <item>
      <title>ATmega32u4 (2)</title>
      <link>/jp/2020/03/29/atmega32u4-2/</link>
      <pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/29/atmega32u4-2/</guid>
      <description>今回も引き続き基本のUSB AVRの ATmega32u4 を中心としたAVRチップのプログラム方法とその環境に関して、 調査と情報の整理をします。
ISP接続 Arduino系の開発ボードなら、6pinのICSPコネクターが付いているので 1pin(ポチマーク)側にAVRISP mkIIからのISP接続フラットケーブルの 赤線側を合わせて挿せば良い ので簡単でした。
ATmega32u4の開発ボードの SparkFun Pro Micro、 Teensy 2.0 や、AT90USB1286の開発ボードの Teensy 2.0++ などやそのコンパチ品はICSPコネクターが付いていないので 「直結接続」が必要です。
「直結接続」のために、以下の写真のように片側にクリップ、 片側にオスやメスのデュポンコネクターが付いたワイヤーを準備 しました。(AVR系をAVRUSP mkIIでISP書き換えするにはオスの デュポンコネクター版だけで充分ですが、将来ARM系のSTM32F等を ST-LINK/V2等で書き換えするのにはメスのデュポンコネクター版が あると便利そうなので両方準備してみました。)
左右逆にしないことが大事なので、接続関係をここにまとめます。
ISP接続フラットケーブルのコネクター （赤線側上です。コネクター穴側から見た「左図」が大事！)
 RED SIDE 赤線側 BTM VIEW コネクター穴側 TOP VIEW VCC 2 1 MISO MISO 1 2 VCC MOSI 4 3 SCK SCK 3 4 MOSI GND 6 5 RST RST 5 6 GND (こっちがメイン) Looking from Looking from the the hole side back of the connector hole 以下、開発ボードの端子はチップが載っている表側(TOP側)から、 USBコネクターを「左」に置き見て、「半時計回り」(CCW)で 「0スタート」(逆方向は-1スタート、角からスタート、重複命名有り) で位置表記し、ISPコネクターの端子は赤線側を上にして、 コネクター穴側から見て位置表記することとします。</description>
    </item>
    
    <item>
      <title>ATmega32u4 (1)</title>
      <link>/jp/2020/03/28/atmega32u4-1/</link>
      <pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/28/atmega32u4-1/</guid>
      <description>前々回・前回は、Arduino Uno/Nano に使われている基本のシリアルAVRの ATmega328P のプログラムの勉強・練習をしました。その結果チップ周辺の配線状態 確認をホストPCのターミナルからするシェルのような avrmon を書きました。
今回は基本のUSB AVRの ATmega32u4 を中心としたAVRチップのプログラム方法とその環境に関して、 調査と情報の整理をします。
ATmega32u4開発ボード ATmega32u4を5V 16MHzで使う開発ボードをしては、 Arduino Leonardo、 Arduino micro、 SparkFun Pro Micro、 RobotDyn Micro ATmega32U4-MU、 Teensy 2.0などや そのコンパチ品が通販サイト(例えば、 banggood、 aliexpress、 ebay )で出回っています。私はTeensy 2.0のコンパチ品を入手しました。
AVRへのプログラム導入 ATmega32u4へのプログラム導入アプローチは、 ATmega328Pへのプログラム導入アプローチ より選択肢が多く混乱しがちなので、以前書いた英語のメモ( Serial AVRや USB AVR )をベースに、日本語で以下に比較しながら状況を確認と整理をします。
Serial AVR Serial AVR (ATmega328P等) では、チップにプログラムを導入するのに 主に２つのアプローチがあります:
 ISP:  ホストPC上でavrdudeをISPモードで走らせ、AVR ISP mkII等の プログラマー経由でSPIポートに接続しATmega328Pを、ハードウエアー だけを用いチップを書き換えます。   Serial:  ホストPC上でavrdudeをArduinoモードで走らせ、D0/D1ピンに TTLレベルのRS-232C接続経由で、チップの上位アドレスに置かれた ブートローダーソフトの助けを受け、チップを書き換えます。 開発ボード上に、FT-232R や CH340 等のUSB-Serial変換チップが 載っている場合、ホストPCから外見的にはUSB接続に見えます。 昔のAtmel STK500 や、昔のArduinoにはブートローダー(4KB)が導入済みです。 Firmwareを探すときにこれらの古いのを踏まないように要注意です。 最近のArduino系の開発ボードでは、サイズを小さくしたブートローダー のOptiboot(512B)が導入済みです。(一押し！)    USB AVR USB AVR (ATmega32u4等) では、チップにプログラムを導入するのに 主に4つのアプローチがあります:</description>
    </item>
    
    <item>
      <title>ATmega328P (4)</title>
      <link>/jp/2020/03/10/atmega328p-4/</link>
      <pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/10/atmega328p-4/</guid>
      <description>前回に続きArduino Uno/Nano に使われている基本のシリアルAVRの ATmega328P を中心としてAVRチップのプログラムの勉強・練習の続きをしました。
AVRのコーディング上の注意点 以下をAVRのコーディング上の注意点の参考にしました。
 2003年出版のIAR CベースのAVR035: Efficient C Coding for AVR 2011年出版のGCC4.5ベースのAtmel AVR4027: Tips and Tricks to Optimize Your C Code for 8-bit AVR Microcontrollers  わたしの現在の開発環境で使うのは、avr-gcc (GCC) 5.4.0です。&amp;ldquo;c99 plus GCC extensions&amp;quot;となるように-std=gnu99をWinAvrベースのMakefileに指定してます。 ちなみに、avr-gcc (GCC) 5.4.0では-std=C99は&amp;quot;ISO C99 standard&amp;quot;完全準拠の はずです。avr-gcc helpの記述に-std=c11、-std=c++11がありISO 2011 C/C++ まで完全準拠が選べるようです。WinAvrのMakefile内に書かれた 「ISO C99準拠が不完全」とのコメントは古いバージョンのavr-gccに基づいている ようですね。確かGCCは4以降では&amp;quot;ISO C99 standard&amp;quot;完全準拠だった気がします。
ちなみに、-std=gnu99では、-std=c11で導入された0b10111011と言った ２進表記での整数定数表記ができます。これが便利です。
8 bitのATmega328Pぐらいにフォーカスして、現在の開発環境下で私なりに検討して、 ある程度の憶測も折り込み、よくまとまっていたAVR035文書の結論を以下に書きなお して見ました。
あまりコードサイズの最適化に頑張り過ぎることは無いと考えています。無理がある 時には、コードを凝るのではなく、所詮趣味でなので実現する機能を削るとか、値段 は知れているので高性能のチップに乗り換えるとかする方が良いのでしょう。実際 Arduino Nanoに載っているATmega328pですらかなり余裕があるので、読みやすくバグ 発生しにくいコーディングを心がけ、デバグしやすいように部分・部分をテストでき るモジュラーな構成を念頭にするもがいい気がします。
そういった意味では、裸のavr-gcc+avr-libcでの開発に拘らずに、Arduino系のインフ ラを利用したコード開発をすれば楽になる面もあるのも事実です。このメモ作成は、 あくまでAVRのコーディングの基礎学習行為の備忘録です。
Hints to Reduce Code Size  Compile with full size optimization.</description>
    </item>
    
    <item>
      <title>ATmega328P (3)</title>
      <link>/jp/2020/03/06/atmega328p-3/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/06/atmega328p-3/</guid>
      <description>前回に続きArduino Uno/Nano に使われている基本のシリアルAVRの ATmega328P を中心としてAVRチップのプログラムの勉強・練習の続きとして、 「AVR Libc Reference Manual」を読み込んでAVR独特の世界をみました。
メモリー PCでのプログラムとはメモリー関係は、少々勝手が違い、IO関係を直接触る上、 メモリー空間も狭いので要注意です。
さらにATmega328Pを含むAVRはﾌﾟﾛｸﾞﾗﾑとﾃﾞｰﾀに対してﾒﾓﾘとﾊﾞｽを分離する ﾊｰﾊﾞｰﾄﾞ構造を使用し、メモリーアドレス空間もそれぞれ別です。 （PCはﾌﾟﾛｸﾞﾗﾑとﾃﾞｰﾀがメモリーアドレス空間を共有するノイマン構造。）
 ﾌﾟﾛｸﾞﾗﾑは不揮発性のフラッシュに格納されます。 ﾃﾞｰﾀは通常の揮発性のSRAMに格納されます。 不揮発データーを格納する別のEEPROMもあります。  ATmega328Pだと：
 ﾌﾗｯｼｭ ﾒﾓﾘ容量 (ﾊﾞｲﾄ) 32K SRAM容量 (ﾊﾞｲﾄ) 2K EEPROM容量 (ﾊﾞｲﾄ) 1K  実際のデーターメモリー領域は以下です。
 ﾚｼﾞｽﾀ ﾌｧｲﾙ (32: 0x00-0x1F)　ーALUの汎用レジスタ I/Oﾚｼﾞｽﾀ (64: 0x20-0x5F) - アセンブラIN/OUT命令は0x20オフセットしたLDS/STS 拡張I/Oﾚｼﾞｽﾀ (160: 0x60-0xFF) 内蔵SRAM (2K: 0x100-0x3FFF)  IN/OUT命令関連のことがよく分からない。どうもAVRの前の世代のマイコン8051の命令 のことのようだ。アセンブラコード移植を意識しているようだ。INTEL系はIOは0x00から 始まる独立アドレス空間なので、アセンブラコードは0x20オフセットした LDS/STS命令に置き換えると言っているようです。
ﾌﾟﾛｸﾞﾗﾑ領域（フラッシュ）へのアクセスには専用のアセンブラコードLPM/SPMがあります。
EEPROM領域へのアクセスは専用のI/Oﾚｼﾞｽﾀ経由で行うようです。
Cコードからは、マクロが準備されているので、ﾌﾟﾛｸﾞﾗﾑ領域たやEEPROM領域へのアクセス には専用マクロ等を使うようだ。詳しくは「ATmega328Pマニュアル」の「ﾃﾞｰﾀ用EEPROMﾒﾓﾘ」や、 「AVR Libc Reference Manual」の「Data in Program Space」や、 avr/eeprom.h や avr/pgmspace.hを参照しましょう。</description>
    </item>
    
    <item>
      <title>ATmega328P (2)</title>
      <link>/jp/2020/03/03/atmega328p-2/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/03/03/atmega328p-2/</guid>
      <description>Arduino Uno/Nano に使われている基本のシリアルAVRの ATmega328P を中心としてAVRチップのプログラムの練習の続きをしました。
確かにハードとして少々古い感はありますが、５V仕様で安価で入手簡単な開発 ボードがあるのが練習用にいい感じです。
開発環境 クロスコンパイル開発環境は以下でOK（2020/03, Debian stable buster）
 $ sudo apt install gcc-avr avr-libc binutils-avr コードスタイル 以下色々なところからコードを引っ張ってくると、コードスタイルが混じって 見づらくなるし、手動で直すのもばかばかしいのでちょっとコードスタイル関係を 調べました。もともとK&amp;amp;R系のTAB無し2-4スペースインデントの 1TBS なので、色々のスタイルガイドを見て、結局 GOOGLEスタイル に最も共感しました。
今後はPython以外は全言語基本2スペースインデントにします。
VIMのモードライン(C)
// vim: set sts=2 sw=2 ft=c ai si et tw=80: VIMのモードライン(SH)
# vim: set sts=2 sw=2 ft=sh ai si et tw=80: VIMのモードライン(PYTHON)
# vim: set sts=4 sw=4 ft=python ai si et: Cの自動リフォーマットは
 $ clang-format -style=Google -i filename.c SHELLの全文リフォーマットはVIMで(modelineが無い場合は:set syntax=shの後)gg=Gとする。</description>
    </item>
    
    <item>
      <title>AVRISP markII mod-VCC (J)</title>
      <link>/jp/2020/02/27/avrisp-mod-j/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/02/27/avrisp-mod-j/</guid>
      <description>AVRチップのISPプログラマにAVR ISP markIIを使うと、対象AVRチップに別途電源供給 する必要があり、ISP出力のPIN#2にVCCを供給していた以前の TTL-232R-5V を使った自作プロクラマー (英語) を使うより煩雑でした。
そこで、AVR ISP markIIを改造し、ISP出力のPIN#2からVCCを供給出きるように改造し ました。
参考情報 いろんな人が同様の不便を感じ、AVRISP mkIIのUSB から電源を取り、ISP出力のPIN#2 に つなぎVCC電源供給ソースとする改造記事を書いています。以下の改造記事を参考に しました。
 http://www.webx.dk/avrisp-mk2-modding/ (3V/5V selectable, use own fuse, easy output) https://jeelabs.org/2010/04/02/avrisp-mkii-w-5v-power/ (nice input after poly fuse) https://forum.arduino.cc/index.php?topic=125502.0 (half ass fix, Nice pics of wiring, good output point) https://qiita.com/hideyuki/items/71381b741d89878e3e79 (Easy access via TP1, No fuse) http://shiozoku.blogspot.com/2014/02/avr-isp-mkii.html Use switch (No fuse, interesting use reminder) https://electronics.stackexchange.com/questions/286693/can-anything-be-done-about-this-avrisp-mkii-or-is-it-dead (Nice pics of wiring, not the same purpose, fix by bypassing broken DC/DC)　これは本改造とは違う修理改造。  どうもこれらの記事の基板の方が私の持っている基板より配線が太く見やすいです。</description>
    </item>
    
    <item>
      <title>ATmega328P (1)</title>
      <link>/jp/2020/02/21/atmega328p-1/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/02/21/atmega328p-1/</guid>
      <description>AVRチップのISP経由プログラムの練習をします。
ATmega328P は手元にあったブレッドボードに挿せるArduino Nanoのコンパチボードや本物の Uno等を使ってます。
プロクラマー これには、 昔TTL-232R-5V を使った自作プロクラマー を使うのも良いのですが、最近Atmel AVR ISP mkIIをただで人からもらったので それを使います。
詳細な使用説明書（英文）： AVR ISP mkII User Guide
ソフト環境 Debian GNU/Linux buster=stable 環境です。
$ sudo apt install avrdude 接続 純正のAVRISP mkIIのVCCは電源電圧監視用でAVRISP mkII側からは電源供給されませんので、 別途チップへの電源供給ソースが必要！Unoなら12V、NanoならUSBを必ずつなぐこと。
ちなみに、 昔TTL-232R-5V を使った自作プロクラマー は電源電圧供給していたので便利な面がありました。
実は当方所有のAVRISP mkIIは、USB 電源 とPIN#1 をつないで電源供給ソースとする改造済みです。 このAVRISP mkIIの改造は、この次の記事です。　改造済みだと外部電源供給は不要ですが、電圧設定を間違いなくする必要があります。
さて、ISPケーブルの赤線は１ピン側です。
Uno Nano AVRISP mkII に赤いLEDがつきっぱなしは、ISPコネクター「差し込み忘れ」です。
AVRISP mkII に赤いLEDが点滅は、ISPコネクター「逆差し」です。
Uno $ sudo avrdude -c avrisp2 -P usb -p m328p -v avrdude: Version 6.3-20171130 Copyright (c) 2000-2005 Brian Dean, http://www.</description>
    </item>
    
    <item>
      <title>自作キーボード(1)</title>
      <link>/jp/2020/01/03/cg56-1/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/jp/2020/01/03/cg56-1/</guid>
      <description>以下は基本的に備忘録です。
2016-2017年頃の自作キーボードのハード作成 Arduinoは素人ででもシステム細部まで理解して プログラム出きるので、それなりに面白いんですが、LEDのチカチカやbeep音出し だけではすぐに飽きてしまいました。
そこでキーボードの自作を思いたち、2016年の年末から海外サイトを色々見ました。
 https://geekhack.org/ &amp;ndash; geekhack https://deskthority.net/ &amp;ndash; deskthority  昔から気になっていたことを根本的に解決してくれる ortholinear系のデザインのキーボードがとっても気になり 欲しくなりました。ただPCBからすべて買って組み立てるだけでは面白くない ので、キースイッチの位置精度が要るケース部品のネタ部分だけを3mm MDF板の レーザー加工で2017年2月に発注し入手しました。
作ろうとしたキーボードのデザインは、14C * 4R のortholinear タイプで、 右端のキーを真ん中に移動し、左右の手を通常より2キー離れて置くことを特徴とし ていました。planck等で採用されている片側6列ではなく片側7列とし、左右の手 の間隔を通常より取ったので窮屈でない姿勢で使えるキーボードのデザインにでき たと一人悦に入っていました。
MDFを木工ボンドで接着し組み立て、角をヤスリで落し、段差を紙粘土で埋めて スムーズな形にして、仕上げに塗装したあと、キーを置いてみて気分を楽しんで いました。
まあ、MDFは木材感覚なので、塗装が出来るのと、角を削って落とせるのは メリットでした。キーはプレートマウント状態ですがMDF板は3mm あり1.0-1,5 mm 厚であるべきマウントプレートとして引っかかりある取り付けができませんでした。 それに関してはキースイッチをホットメルト接着剤で裏から留めることで安定させ たので、むしろカンカンという金属板の共鳴音もしなくていい感じでした。
ただその後、他の事に忙しくなり、電子回路を組み上げずに中断していました。 (ケースの高さを抑えかつ強度を確保しようとし過ぎため、ケース内のスペース が少なく配線の作業性が極端に悪かったのも挫けた一因です。)
キーボード関連MCU・ソフト状況 このころいろいろ読んでの、私なりのキーボード関連でのソフトに関する結論を 備忘録で記します。
(昔、この辺は英語でhttps://github.com/osamuaoki/avrdude-friend/wiki に纏めていました。ちょっと加筆して整理しなおしました。今見直すとかなり 参考になります)
まず、USBキーボードに使うMCUはやはりサポートソフト基盤のARDUINOやQMKがあり とっつきが良いATmega32u4に絞りました。読み込んだ資料は以下です。
 atmega32u4 data etc. atmega32u4 データシート LUFA: the Lightweight USB Framework for AVRs Arduino The QMK Configurator &amp;ndash; Open-source keyboard firmware for Atmel AVR and Arm USB families  いくつか気づいたポイントを以下に箇条書きにします。</description>
    </item>
    
    <item>
      <title>AnthyのBuildトライ(2)</title>
      <link>/jp/2019/09/01/jpn-ime-resource-08/</link>
      <pubDate>Sun, 01 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/jp/2019/09/01/jpn-ime-resource-08/</guid>
      <description>0.4に向けた変更 Debian Busterの(0.3系)のAnthyに関して、Busterはフリーズ中なので、 リリースの邪魔をしない苦肉の策として、機能的に最低限必要なバグ修正のみに 対応したパッケージをDebianのexperimentalに anthy 1:0.3-9 としてアップロードしました。
その後、gniibeさんから連絡があり、私の提案とは少し違ういい感じで改訂され anthy 1:0.4-2 がリリースされました。これでひとまず解決したので、 当面AnthyのBuildトライは休憩することにしました。
過去のBuildトライ時の問題点 治ったとは思いますが、以前気になった点を備忘録でここに記します。
「だよ～ん」無限ループ問題です。これはコーパス修正による回避ではなく、 calctrans.cが呼ぶproccorpus.cを見直し無限ループに入らないようにしました。 bdd71e4 (&amp;ldquo;Ignore problematic line to avoid infinite loop&amp;rdquo;, 2019-05-31)
さらに、平成の市町村合併前のZIPコードのままなのは気になります。まあ、郵便局 の元データーから作り直すのも手なんですが、実際に使えるデーターとするには 一部手動調整があります。ライセンス的にはskkでもmozcでも、どちらのZIPデーター でも良かったのですが、京都市街中心部の歴史的住所がうまく手動調整されていた skkのデーターが気に入ったので、簡単にvimで整形して置き換えました。
波ダッシュ問題 どうも、世間の常識のようですが、「波ダッシュ問題」に気づきました。 Buildトライ時に気づいたことをメモしておきます。
0.3のコーパス中で問題となっていたのは 「～」(UTF-8: EF BD 9E, U+FF5E)全角チルダです。 ibus-anthyでチルダで入力できるのは 「～」(UTF-8: EF BD 9E, U+FF5E)全角チルダです。 ibus-mozcでチルダで入力できるのは 「〜」(UTF-8: E3 80 9C, U+301C)波ダッシュです。
これで気になって、波ダッシュ WAVE_DASH (Shift_JIS:0x8160, Unicode:U+301C)と 全角チルダ FULLWIDTH_TILDE(Shift_JIS:0xFF5E, Unicode:U+FF5E)の違いや状況を 調べてみました。結論は、日本語の文中に書く「波ダッシュ」は本来の「波ダッシュ」 U+301Cが正しいようだ。Windows XP以前のデーターは「波ダッシュ」が見た目で文字化 けするので、これを避けるために「全角チルダ」を本来の「波ダッシュ」の代用に使っ ているようです。
 波ダッシュ・全角チルダ問題 波ダッシュ チルダ Wikipedia:表記ガイド: 波ダッシュ https://xhtml.</description>
    </item>
    
    <item>
      <title>日本語単語頻度 (2)</title>
      <link>/jp/2019/05/27/word-freq-02/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/jp/2019/05/27/word-freq-02/</guid>
      <description>以前書いた、Unidicを用いた単語出現頻度情報 をさらに読み込んでみた。
品詞ごとのBCCWJの表中出現語数比率 BCCWJの表中の語彙の品詞ごとの出現語数比率の高頻度部分は：
   単語 頻度(%)     名詞-普通名詞-一般 48.11%   名詞-固有名詞-人名-一般 12.10%   名詞-固有名詞-地名-一般 8.25%   名詞-固有名詞-人名-名 5.80%   名詞-普通名詞-サ変可能 5.39%   動詞-一般 5.10%   名詞-固有名詞-人名-姓 4.98%   名詞-固有名詞-一般 4.52%   副詞 1.66%   名詞-普通名詞-形状詞可能 0.85%   形状詞-一般 0.74%   形容詞-一般 0.42%   接尾辞-名詞的-一般 0.36%   名詞-固有名詞-地名-国 0.28%   名詞-普通名詞-助数詞可能 0.</description>
    </item>
    
    <item>
      <title>AnthyのBuildトライ(1)</title>
      <link>/jp/2019/05/12/jpn-ime-resource-07/</link>
      <pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/jp/2019/05/12/jpn-ime-resource-07/</guid>
      <description>Debian Busterの(0.3系)のAnthyは問題がある。
一方、mozcの最新コードや辞書を見たら、昔よりかなり整理され 変なデーターで無理やり特定コーパスのみの最適化というか過学習 の結果のような辞書データーもない。使ってみると正直悪くない。
いまさらanthyを触るのもという感もあるが、せめて以前程度に 動くようにはしたい。特にDebianのパッケージは完全メンテナー モードで、salsaでバグ修正優先での対応を考えます。 （githubは、いろいろ遊ぶかもしれません）
すぐ気づいた明らかなバグ２つは解決法が見えた。
 Use UTF-8 for zipcode bug fix. Closes: #927074 Convert depgraph/master.depword to UTF-8. Closes: #923948  後者は文法係り受け定義関連を再構築必要がある。簡単にするには debian/rulesを以下としてDebianのビルドシステムでdebuildと してビルドする必要がある。
override_dh_auto_configure: dh_auto_configure -- --sysconfdir=/etc/anthy --enable-maintainer-mode だが、上手くいかない。ソース壊れている?
UTF-8 での処理のデフォルト化 まず、テスト環境で変な文字が出るので気になっていた、UTF-8廻りを 確認した。
anthy/anthy.hに以下と定義されているので、encoding関係が 初期値の0だと、どうも出力がEUCJPになってしまうようだ。
#define ANTHY_UTF8_ENCODING 2 これは、0にしておかないとdefault_encodingやencodingやprint_encoding などがUTF-8にならない懸念がある。2としている意味を感じなかったので これを変えた。特に以下への影響が気になる。
 anthy_putxchar() anthy_putxstr() anthy_putxstrln()  これらは、以下で使われている。
 mkworddic/mkdic.c src-main/context.c src-splitter/metaword.c src-splitter/wordlist.c src-worddic/record.c src-util/convdb.c test/check.c  まあ、道理でparsed_data0がUTF-8環境で読めない。どうもEUCJPで文字列 をはき出しているわけです。これじゃ、まともに動かないのも納得です。 きっと連接の統計がまともにできていないので、連文節変換をすると変な 結果が出るようになったのだろう。とりあえず、修正。
さらによく見ると、calctrans/proccorpus.cが以下になっている。
 anthy_conf_override(&amp;#34;CONFFILE&amp;#34;, &amp;#34;../anthy-conf&amp;#34;); これは、ビルド中のソース内のファイルを見てほしいので以下にする。</description>
    </item>
    
    <item>
      <title>Anthyの文法係り受け定義(1)</title>
      <link>/jp/2019/05/11/jpn-ime-resource-06/</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/jp/2019/05/11/jpn-ime-resource-06/</guid>
      <description>まず、anthy.dic作成時の構成要素のanthy.depに組み込まれる、 ソースファイル内での文法係り受け定義関連の要点をレビューしました。
使ったanthyのソースはDebian BusterのベースとなるgniibeさんがUTF-8化パッチ を掛けかなり変更した0.3です。
anthy.depは、基本的にdepgraph/内のファイルから生成されます。
Anthyの文法係り受け定義 単文節内の、単語結合の遷移ルールが「接頭辞 自立語 接尾辞 付属語」 という順の結合で定義されるとして、以下の２段階ででデーターファイルを 読み込みanthy.depの中に書き出し文法係り受けルールを定義します。
 付属語グラフを、init_depword_tab()が、付属語に関する日本語表現を使った結合ルールをall.depword から読み込みメモリー中に作成します。 自立語からの遷移表を、init_indep_word_seq_tab()が、indepword-wt.txtから自立語のソースの辞書内で用いる品詞ニモニック文字列と対応する日本語表現を読み込み作成します。  ここで、Anthyで言う付属語とは、活用語尾を含みます。
付属語グラフ 付属語ノードの結合ルールは、活用語尾や助詞や助動詞等のノードが一定の規則 にしたがって並んで、次のノードに遷移していくグラフ構造モデルです。
この付属語グラフを規程するために読み込まれるall.depwordは、 活用語尾を定義したconjugate.tableと助詞や助動詞等のノードを定義した*.depwordを、 sedでコメント行を除き結合して生成します。
このall.depwordは、基本的に
@ノード名 &amp;#34;そこに続く単語1&amp;#34; &amp;#34;そこに続く単語2&amp;#34; .. &amp;#34;..n&amp;#34; \ @遷移するノード名1 @遷移するノード名2 .. @遷移するノード名m という形式の行の繰り返しです。(読みやすいように折り返しましたが、 通常１行で記載します)
終端で次のノード名がない場合には、そこに@のみを遷移するノード名 として記します。
上記では、@遷移するノード名と典型的な場合をイメージした形式で記しま したが、実際にはもう少し多くの情報を盛り込めます。具体的には {遷移の属性}{接続の強さ}@ノードの名前という形式です。
遷移の属性は、depgraph/parse_transition()にあるtokenでswitchするcase分岐 構造のコードで扱われ、DOC/SPLITTERに説明されたアルファベット２文字の ニモニックです。ここにそれを内容をコードに揃えてアップデートし再録説明すると、
 活用形  未然形 Cz (ct = CT_MIZEN) 連用形 Cy (ct = CT_RENYOU) 終止形 Cs (ct = CT_SYUSI) 連体形 Ct (ct = CT_RENTAI) 仮定形 Ck (ct = CT_KATEI) 命令形 Cm (ct = CT_MEIREI) 語幹形 Cg (ct = CT_HEAD)   自立語部の品詞  動詞 Hv (pos = POS_V) 名詞 Hn (pos = POS_NOUN) 形容詞 Hj (pos = POS_AJV)   文節の属性  名詞句?</description>
    </item>
    
    <item>
      <title>Anthyの辞書ファイル(1)</title>
      <link>/jp/2019/05/10/jpn-ime-resource-05/</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/jp/2019/05/10/jpn-ime-resource-05/</guid>
      <description>まず、辞書関連ファイルの要点をレビューしました。
使ったanthyのソースはDebian BusterのベースとなるgniibeさんがUTF-8化パッチ を掛けかなり変更した0.3です。
Anthyの辞書関連定義ソースファイル 変換候補漢字が、読みに対して、その品詞、頻度とともに定義される「辞書」ファイルは、 その作成経緯により2種類の拡張子が使われています。
 Anthy用辞書: *.t Canna用辞書: *.ctd  これらはすべてalt-cannadicとmkworddicにあります。
単純な品詞や頻度だけでは正しい漢字選択ができない場合に対応する「用例辞書」 ファイルudictはmkworddicにあります。
Anthyの辞書ソースファイル処理機構 上記の「辞書」ファイルと「用例辞書」ファイルは、mkworddicディレクトリー 中にビルド時に生成されるmkworddicにより読み込まれ、さらに負の頻度を持つ 「逆変換用辞書」データーが追加作成されます。
これを詳しく見ていきましょう。
mkworddicが-fオプションでdict.argsを指定して起動されます。dict.args は通常同一ディレクトリー内のdict.args.in`からビルド時作成されます。 これを変更することで組み込まれる辞書は調節できます。
dict.argsの設定内容の処理は、mkworddic/mkdic.c:execute_batch()で処理されます。
 readコマンドは指定された「辞書」ファイルをread_dict_file()で読み込みます。 read_ucコマンドは指定された「用例辞書」ファイルをread_udict_file()で読み込みます。 build_reverse_dictコマンドは「逆変換用辞書」データーをbuild_reverse_dict()で作成し追加します。 writeコマンドはメモリー中の全辞書データーを指定されたファイル（anthy.wdic）にwrite_dict_file()で書き出します。  詳細は、mkworddicのソースをmkworddic/mkdic.cから追いかけると見えてきます。
ちなみに、anthy.wdicは、mkanthydic/ディレクトリーのファイルから生成するビルド 時用のバイナリープログラムmkfiledicにより、単語の条件付き連鎖発現頻度情報を整理 して生成する各種情報ファイルと統合され、漢字かな変換実行時に用いられるanthy.dic となります。
Anthyの辞書ソースファイル構造(基本) mkanthydic/mkdic.c:push_back_word_entry_line()からコードを読むと辞書ファイルの 構造が分かります。
最も典型的な辞書ソースデーターファイルの構造は、半角スペースで区切られた以下の 構造をしています。
&amp;lt;ひらがな見出し語&amp;gt; [#&amp;lt;品詞&amp;gt;[*&amp;lt;頻度&amp;gt;] [&amp;lt;変換後文字列&amp;gt;]... ]...  &amp;lt;ひらがな見出し語&amp;gt; (index)は、全角ひらがな以外の半角・全角の数字や記号も許されます。 *&amp;lt;頻度&amp;gt;は省略可能です。 &amp;lt;変換後文字列&amp;gt;は同音異字に関して繰り返し羅列可能です。 #&amp;lt;品詞&amp;gt;*&amp;lt;頻度&amp;gt; [&amp;lt;変換後文字列&amp;gt;]... も繰り返し羅列可能です。  #&amp;lt;品詞&amp;gt;に関しては後述する。
ただし、現在は「&amp;lt;ひらがな見出し語&amp;gt;」は30文字までに制約されています。この他、 プログラム内の各種文字列長は固定長でいろいろ制約があることが多いので要注意です。
またindex中の濁点は通常「が」のように１文字表現をしますが、１文字表現の無い 「う゛」は２文字表記されています。
辞書中に「う゛」を「ヴ」で置き換えた項目を入れることはDebianが使っている 0.3のソース中ではされていません。現在のanthyの入力対応は、ひらがな・ カタカナ・ローマ字で、入力はひらがなに変換してから漢字変換操作がされるので、 「ヴ」は自動的に「う゛」となります。だからたとえ、フロントエンドがibusの 場合で「ヴ」をひらがなに混ぜて返す仕様となっていても問題は起こりません。 辞書中の「&amp;lt;ひらがな見出し語&amp;gt;」に「ヴ」を書くのを加えるのは 使われない無駄なデーターとなるので好ましくありません。（辞書ファイル中の README中の文言は無視しましょう）
 src-main/main.c:need_reconvert() src-worddic/word_dic.c:anthy_get_seq_ent_from_xstr()  このソース辞書から作られるanthy.</description>
    </item>
    
    <item>
      <title>unidic固有名詞カタカナ問題</title>
      <link>/jp/2019/05/06/jpn-ime-resource-04/</link>
      <pubDate>Mon, 06 May 2019 13:00:00 +0900</pubDate>
      
      <guid>/jp/2019/05/06/jpn-ime-resource-04/</guid>
      <description>Unidicの頻度情報は日本人名をカタカナ登録で処理している。
かな漢字変換のデーターを作るのにはこれではまずいので別情報で漢字補完すべきです。 さてどうするべきか？
姓名 2019-05-07:内容追加
日本人姓名をカタカナ表記化で集約統計するのは頻度情報集計時の追加後処理 操作のようです。
mecab処理に使うunidicの元ファイルの辞書lex.csvには漢字も収録されていました。
たとえば、「ヒロシ」だと：
ひろし,14726,15499,7326,名詞,固有名詞,人名,名,... ヒロシ,14726,15499,1100,名詞,固有名詞,人名,名,... 博,14726,15499,5515,名詞,固有名詞,人名,名,... 博史,14726,15499,6555,名詞,固有名詞,人名,名,... 博司,14726,15499,6556,名詞,固有名詞,人名,名,... 博士,14726,15499,8204,名詞,固有名詞,人名,名,... 博師,14726,15499,6556,名詞,固有名詞,人名,名,... 博志,14726,15499,6556,名詞,固有名詞,人名,名,... 博至,14726,15499,6556,名詞,固有名詞,人名,名,... 博詞,14726,15499,6556,名詞,固有名詞,人名,名,... 博資,14726,15499,6556,名詞,固有名詞,人名,名,... 啓,14726,15499,7246,名詞,固有名詞,人名,名,... 啓史,14726,15499,6556,名詞,固有名詞,人名,名,... ... 数えると「名詞,固有名詞,人名,名」で読みが「ヒロシ」が８６ありました。 他の名前情報源の列挙数と比較して遜色なくこれだけで十分な感じです。
ちなみに、lex.csvの最初の4つは必須エントリの意味は
 表層形 左文脈ID (単語を左から見たときの文脈 ID) 右文脈ID (単語を右から見たときの文脈 ID) 単語コスト (小さいほど出現しやすい)  となっています。
こうなると、４つ目のエントリが最小の1100の「ヒロシ」が代表とも言えるし、 漢字で選ぶなら「博」を第一番目漢字変換候補とするなどで簡単に候補序列の 設定にも対応できそうです。
難しそうだった名前でこれですから、姓の方はもっと簡単ですね。
以下の記事の姓名の頻度感は面白いので、ここにほぼ元の形で残し、改訂します
ちなみに、頻度関連情報ですが、頻度順位（rank）には「#」を数字の前につけ表記し、 発生頻度はpmw(1000,000語あたりの発生数)で表記しています。
名字 名字は地名と重なることが多いので、その漢字から漢字設定をし、 品詞を固有名詞（地名・名字可）とでもしていけば、多くは漢字の補完が 来きる可能性がある。特に全国郵便番号の地名（漢字＋カナ）は網羅的で有効。 沖縄の変わった名前なども、意外と地名にあります。
名字の参考情報 全国名字ランキング による情報にrank pmwを合わせて比較 （40000位まである公開順位情報の一部のFAIR引用）
 RANK PMW cost 1位	佐藤	およそ1,880,000人　#2773 30 4251 2位	鈴木	およそ1,802,000人 #2855 29 2538 4位	田中	およそ1,340,000人 #2289 38 2734 10位	加藤	およそ890,000人 #3916 19 5087 20位	清水	およそ533,000人 #5854 11 2814 40位	坂本	およそ327,000人 #6348 10 4586 100位	杉本	およそ182,000人 #13375 3.</description>
    </item>
    
    <item>
      <title>辞書ライセンス問題</title>
      <link>/jp/2019/05/06/jpn-ime-resource-03/</link>
      <pubDate>Mon, 06 May 2019 13:00:00 +0900</pubDate>
      
      <guid>/jp/2019/05/06/jpn-ime-resource-03/</guid>
      <description>辞書のライセンス V.2.x以降の現代書き言葉UniDic（旧名：unidic-mecab）および、Ver.2.2.x以降の 現代話し言葉UniDicは、完全なフリーソフトウェアになりました。 GPL/LGPL/BSD Licenseのトリプルライセンスですので、営利目的での利用模含めて 自由に行うことができます。一番良いです。
Jumann++ や mecab-ipadic-neologdは、&amp;ldquo;Apache License, Version 2.0&amp;rdquo; です。
SJ3 は BSDライセンスのようです。
ちなみに、&amp;ldquo;Apache License, Version 2.0&amp;quot;はGPLとのライセンスとしての互換性を改善 されているとのこと。
これらデーターベース辞書を利用して逆変換できないところまで抽出加工処理して、 特定の目的のためのデーター構造を持った内容のデーターベース辞書を 「新たなデーターベース辞書」として作った場合、そのライセンスはどうあるべきかは、 基本的に「新たなデーターベース辞書」の作成者が設定すると考えます。
そもそも辞書データーとは、元の著作権のある各種文書データーから、元文書での使用 例を参考に元の著作権の影響を受けないよう編集し新規に作成したもので、他の辞書 情報も作成の際に参考にして作成しるわけで、それでも新規性ある別の物として作成 される物です。
まず、元情報を利用条件を守って利用する必要はあります。ただ、研究調査での使用 許可等があれば、それを使って「新たなデーターベース辞書」を作成した場合、 元ファイルを同梱しない限り、「新たなデーターベース辞書」の頒布に元辞書を継承 する必要は無いと考えます。
もちろん、他者が作成した元情報が逆変換で選択抽出できる場合は、元ファイル自体 が物理的に含まれなくとも元ファイルを同梱と実質的に同じ状況ということで、 「新たなデーターベース辞書」だけではないので、元データーのライセンスの 頒布条件の回避はできません。つまり、その場合には「新たなデーターベース辞書」 も元ファイルの頒布条件を遵守をする必要があるのは言うまでもありません。
新規辞書作成を考える場合、情報源として入手した頻度情報は「事実」なので、 その物自体は排他的に所有できないと考えます。ただし、提供形態やデーター構成 には著作権があるかもしれないので、新規データー作成する際には完全に逆変換がで きないよう、作成者の新規判断と折込や・作成者が工夫した方法で他情報と組み合 わせたり・数値情報の目的に合わせた粗化処理がされるべきです。
漢字かな変換データー辞書の作成で、参照辞書の使用条件を守りながら研究用に使用し、 同音異字のpmwをひらがな表記が同じ品詞の和で抽出するとか、出現順位で抽出する とか、10倍ごとのバケット表記とする等で抽出することで、逆変換不可能にした データーとすれば、その作成されたデーターは「新たなデーターベース辞書」と考 えられ、それら抽出済みデーターをソースとして用いる限り参照辞書の頒布ライセン ス制約の対象外と考えます。
同音異字は結局何らかの少し離れたところまでの近接語効果を入れない限り、頻度だ けや文法的制約からだけでは解消しないので、同音異字の中の頻度１番以外の言葉の 以外は頻度情報は順位以外は重要ではありません。
まあ、如何にライセンスコンタミを防ぐかは微妙な問題ではあります。</description>
    </item>
    
    <item>
      <title>日本語辞書リソース</title>
      <link>/jp/2019/05/05/jpn-ime-resource-02/</link>
      <pubDate>Sun, 05 May 2019 12:00:00 +0900</pubDate>
      
      <guid>/jp/2019/05/05/jpn-ime-resource-02/</guid>
      <description>フリー（無償）で入手し、研究用なら制約無く使用ができる各種辞書の情報です。
Unidic  語彙数: 87万語 (2018-03版) GPL/LGPL/BSD License 新　UniDic 2.2GB 旧　UniDic MeCab で UniDic 辞書を使ってみる  $ wc -l lex.csv 872831 lex.csv 活用形はすべて展開して、それぞれ１行のデーターとなっている。
もし頻度表が全辞書形と考えると、表層形900K/辞書形180Kと大きいとも言えるが、 スマホ写真１枚分のデーターより小さいともいえる。
canna辞書(Anthy)  語彙数: 13万の読みの異なる言葉 GPL  $ wc -l gcanna.t 137488 gcanna.t このファイルは現代的な感覚では、4.6MBと非常に小さい。
各種情報も織り込んだBinary辞書のanthy.dicでも23MB程度。
Mozc /usr/lib/mozc/mozc_serverは、約18MBという巨大なサイズがある。
これは、辞書をプログラムないのメモリーイメージで静的内蔵しているためと 推察される。でも写真数枚程度で、現代的な感覚ではメモリー常駐させるのが 十分可能なサイズともいえる。
$ du -Sh . 59M $ wc -l id.def 2652 id.def ソース中の辞書ファイルサイズ概算59MBと６０MB近くありAnthyより１桁大ききい。 品詞分類数は2652ときめ細かい。
ソース中の辞書ファイルは100K行のデーターが定義されたファイルで １０個ほどあるので、展開済み登録語彙数は約１００万語程度と見受ける。 こうみてもanthy等の１０倍の単語登録がある。(ただし、Anthyは１行に複数語 登録するので実際の差は小さいかもしれない。)
まあデーターが巨大なので変換精度は上がるが、リソース消費が大きく動作が重く なる懸念がある。
Jumann++  基本語彙辞書 3万語 WEB等含む合計 90万語 Apache License, Version 2.</description>
    </item>
    
    <item>
      <title>日本語入力(anthy)関係リソース</title>
      <link>/jp/2019/05/05/jpn-ime-resource-01/</link>
      <pubDate>Sun, 05 May 2019 01:29:00 +0900</pubDate>
      
      <guid>/jp/2019/05/05/jpn-ime-resource-01/</guid>
      <description>anthy 関連のリソース（日本語中心）  Original upstream  https://ja.osdn.net/projects/anthy/   Easy to read mail archive  https://www.mail-archive.com/anthy-dev@lists.sourceforge.jp/thrd1.html https://www.mail-archive.com/anthy-dev@lists.sourceforge.jp/thrd2.html https://www.mail-archive.com/anthy-dev@lists.sourceforge.jp/thrd3.html   Debian (*****)  wiki: http://wiki.debian.org/Teams/DebianAnthy salsa: https://salsa.debian.org/debian/anthy/tree/debian (current) salsa: https://salsa.debian.org/input-method-team/anthy (old)  BTS: https://bugs.debian.org/cgi-bin/pkgreport.cgi?src=anthy   G-HAL (engine patch)  2019-04-06: http://www.fenix.ne.jp/~G-HAL/soft/nosettle/im.html#anthy 2018-05-31: http://www.fenix.ne.jp/~G-HAL/whatsnew/20182nd.html#whatsnew2018530 2011-10-08: http://www.fenix.ne.jp/~G-HAL/soft/nosettle/anthy.html   vagus (dictionary patch)  2012-03-10: http://vagus.seesaa.net/ https://osdn.net/projects/alt-cannadic/wiki/FrontPage   ootnegx  2011-12-03: http://ootnegx.blogspot.com/2011/12/g-hal-anthy.html   archlinux wiki  2018-08-30: https://wiki.archlinux.jp/index.php/Uim_%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%82%92%E5%85%A5%E5%8A%9B#Anthy   kakurasan  2010-11-20: https://kakurasan.</description>
    </item>
    
    <item>
      <title>キーボード入力モード選択</title>
      <link>/jp/2019/03/23/gnome-uskb-im-select/</link>
      <pubDate>Sat, 23 Mar 2019 18:59:13 +0900</pubDate>
      
      <guid>/jp/2019/03/23/gnome-uskb-im-select/</guid>
      <description>キーボード入力モード選択 Gnome等のLinuxの日本語環境でキーボード入力モード選択がトグル（ローテート） 動作（日本語/英語の交互切り替え)だと今どっちか分からなくなって結構不便です。
SUPER-SPACEとSHIFT-SUPER-SPACEがGnomeの側でのキーボード入力ソースの デフォルトの切り替えキーです。
input method内での切り替えは、昔のWindowsと同じ&amp;quot;zenkaku-hankaku&amp;quot;とか、 Unix系では良く使う&amp;quot;Shift-space&amp;quot;が良くバインドされています。
切り替えが、状態が分からなくとも一発でできるのが望ましいので、 その設定方法を以下に記します。
日本語キーボードのIM側の設定方法 日本語キーボードだと、変換と無変換キーを、Anthyの入力モード HiraganaとLatinへの切り替えにAnthyの中のキーバインディングで 設定して常にibus-anthyで使うことで何とかなります。これは特に 問題ありません。
 変換キー: 全角かな入力 (hiragana mode) 無変換キー: 英数半角入力 (latin mode)  ALT-漢字、漢字、ALT-`等でのトグル動作が嫌いで、Macの真似でこんな キーバインディングしています。
Windows10でもトグル動作が嫌いで、OS側から プロパティ → 詳細設定 → キー設定　変更 として以下の設定で同様の操作感にそろえています。
 変換キー: IME-ON (IMEは全角かな入力モードにしておく) 無変換キー: IME-OFF  英語キーボードでのIM側の設定方法 (ibus+Anthy) ただ、英語キーボードの場合は変換と無変換キーはありません。
 SHIFTと普通の文字との組み合わせは論外。 CTRLと普通の文字との組み合わせも、VIM使うので全部先約有り。 ALTと普通の文字との組み合わせも、メニューへのショートカットで全部先約有り。  こういったことも有り、私はAnthyの中のキーバインディングで CTRL-SPACE, SHIFT-SPACEを一時使っていました。
ところが、SHIFT-SPACEやCTRL-SPACEのどちらかをLokalizeなどのアプリ が使っていました。（ALT-SPACEは既にGNOMEが使っている）こうなると、 お手上げです。
結局今は、Anthyの中のキーバインディングは以下にしています。
 SHIFT-SPACE: 全角かな入力 (hiragana mode) 変換キーも CTRL-SPACE: 英数半角入力 (latin mode) 無変換キーも  Windows10でも英語キーボードの場合にはOS側から プロパティ → 詳細設定 → キー設定　変更 として以下の設定で同様の操作感にそろえています。</description>
    </item>
    
    <item>
      <title>anthyのユーザー辞書</title>
      <link>/jp/2019/02/09/anthy-dict/</link>
      <pubDate>Sat, 09 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/jp/2019/02/09/anthy-dict/</guid>
      <description>2019-05-11:加筆修正。
Anthyのソースを見るとメイン 辞書以外のユーザー辞書は、単漢字入力などの入力文字列として半角tを最後 につけた辞書が、ファイル名「*.t」で多数含まれ配布されています。
（もっとも、現在のDebianのソースは NIIBE Yutakaさんが最近再構成したので、 ファイルの起源はどうもalt-cannadicは由来かもしれません）
これらは個人用辞書用と言うことですが、現在（２０１９年２月）の時点では 「郵便番号→住所」変換をするためのzipcode.t以外はバイナリーパッケージに コピーされていないので直接システムに導入するようにはなっていません。
ただ同梱された「郵便番号→住所」変換をするための辞書は「７桁半角数字」 を入力すると郵便番号に対応する住所の文字列を吐き出すようになっているように 見受けます。&amp;ndash;&amp;gt; ７桁半角数字が変換されないように見えたのはDEBIANのバグでし た。 2019-05-06: Debian BTS
実際にanthyをibus-anthyの下で動作させると「７桁半角数字」を入れても何も起こりません。 ibus-anthyの下では、現在このzipcode.tは明らかに使えません。Busterは既にフリーズ中 なのでこの修正は次回リリースやバックポートで入るように提案していきます。
（zipcode.tは「t」で終わるトリックは使っていません。）
良く見るとibus-anthyが
/usr/share/ibus-anthy/dicts/emoji.t /usr/share/ibus-anthy/dicts/era.t /usr/share/ibus-anthy/dicts/oldchar.t /usr/share/ibus-anthy/dicts/symbol.t /usr/share/ibus-anthy/dicts/zipcode.t をインストールして、GUIの設定が「~/.anthy/*.t」からシムリンクをはるなど してこれらをibus-anthyのGUIでユーザー辞書として使えるようにしているようです。
ただこれらのユーザー辞書では、入力文字列として半角tを最後つけることはされて いません。「郵便番号→住所」変換をするための辞書は「３桁全角数字、 全角の長音(UTF-8=E383BC, Unicode=U+30FC)、４桁全角数字」を入力すると、 郵便番号に対応する住所の文字列を対応させるようになっていますし、実際の 動作もそうです。
どうもこの違いは、使うフロントエンドによって提供されるローマ字入力からかな に変換される際のルールが異なるので、ibusでは小文字のtが入れにくいことにある ようです。（「uim」は使っていないのであくまで推測です）
 「ibus-anthy」 数字・記号入力は全角数字・記号、単ローマ字入力は大文字半角 「uim」 数字・記号入力は半角数字・記号、単ローマ字入力は小文字半角  ローマ字入力からのかな漢字変換は、どうも使うフロントエンドによって少々動作が 違うので要注意です。
そもそもこの変な小文字のtを末尾に入れる変換辞書スタイルは、 昔の「canna辞書」由来かもしれません。
2019-05-22: 上記メモを書いた後いろいろ試して、FREEZE中なのでDebianの experimentalにバグ修正版1:0.3-9をアップロードしています。７桁数字での 郵便番号はちゃんと出るようになりました。</description>
    </item>
    
    <item>
      <title>日本語単語頻度 (1)</title>
      <link>/jp/2019/02/09/word-freq/</link>
      <pubDate>Sat, 09 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/jp/2019/02/09/word-freq/</guid>
      <description>BCCWJ Unidicを用いた単語出現頻度情報
 語彙調査データ： (古い)  https://pj.ninjal.ac.jp/corpus_center/archive.html （２００４） https://pj.ninjal.ac.jp/corpus_center/files/goihyo_frq_ver.1.0.txt 3万語   『現代日本語書き言葉均衡コーパス』語彙表：(新しい)  https://pj.ninjal.ac.jp/corpus_center/bccwj/freq-list.html （２０１１） https://pj.ninjal.ac.jp/corpus_center/bccwj/bcc-chu-suw.html (1.0E8 data, 短単位語彙表：18万語網羅、748MB） https://pj.ninjal.ac.jp/corpus_center/bccwj/bcc-chu-luw.html (8.3E7 data, 長単位語彙表: 243万語網羅、1GB）    $ wc -l BCCWJ_frequencylist_* 2434722 BCCWJ_frequencylist_luw_ver1_1.tsv 185137 BCCWJ_frequencylist_suw_ver1_1.tsv 辞書形ごとにまとめて頻度統計を行っている。
活用語の辞書形集約はあまり違和感が無かったが、要注意は固有名詞である。 人名の姓と名はカタカナ表記を辞書形（LEMMA)として集約されている。
BCCWJ短単位語彙の累積頻度    単語 頻度順位 頻度(pmw) 累積頻度     の 1 48383 0.048   と 10 21773 0.303   持つ 100 885 0.556   決まる 1000 90 0.</description>
    </item>
    
  </channel>
</rss>
