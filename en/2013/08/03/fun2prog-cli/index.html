<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Fun to Program -- CLI programs | Goofing Osamu</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/en/">English</a></li>
      
      <li><a href="/jp/">Japanese</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Fun to Program &ndash; CLI programs</span></h1>

<h3 class="date">Date:
2013/08/03 (initial publish),
2025/09/06 (last update)
</h3>
<h3 class="source">Source:
fun2-00003
</h3>
</div>

<main>


<table width="100%">
  <tbody>
  <tr>
  
  <td align="left" width="33%"><a href="/en/2013/08/02/fun2prog-hello/">Previous Post</a></td>
  
  <td align="center" width="33%"><a href="/en/">Top</a></td>
  
  <td align="right" width="33%"><a href="/en/2013/08/04/fun2prog-fibo/">Next Post</a></td>
  
  </tr>
  </tbody>
</table>

<h2>TOC</h2>

<nav id="TableOfContents">
  <ul>
    <li><a href="#cli-programs">CLI programs</a>
      <ul>
        <li><a href="#shell">Shell</a></li>
        <li><a href="#python">Python</a></li>
        <li><a href="#lua">Lua</a></li>
        <li><a href="#perl">Perl</a></li>
        <li><a href="#c">C</a></li>
        <li><a href="#c-1">C++</a></li>
        <li><a href="#vala">Vala</a></li>
      </ul>
    </li>
  </ul>
</nav>

<blockquote>
<p>This was originally written and created around 2013 and may require to be
updated. (2021)</p>
</blockquote>
<h2 id="cli-programs">CLI programs</h2>
<p>The command line interface (CLI) program requires to parse its command line
arguments.  Here are simple example code snippets.</p>
<p>Please note I chose the coding style which is the most legible for each
language.  I know there are other ways &hellip;</p>
<h3 id="shell">Shell</h3>
<h4 id="shell-script-short-option-only">Shell script (short option only)</h4>
<p>Shell program with short command line options.</p>
<p>Source code for the shell script: cli_s</p>

<pre><code>#!/bin/sh
verbose=0
while getopts &#34;af:v&#34; opt ; do
    case $opt in
    a)	echo &#34;Option a&#34;
    	;;
    f)	cat &#34;$OPTARG&#34;
    	;;
    v)	verbose=1
    	;;
    -)	break
    	;;
    ?)	echo &#34;Usage: $0: [-a] [-v] [-f file] args ...&#34;
    	exit 1
    	;;
    esac
done
shift $(($OPTIND - 1))
printf &#34;Remaining arguments are: %s\n&#34; &#34;$*&#34;
 
</code></pre>

<p>Please note shell variables are used.</p>
<ul>
<li>OPTARG : option argument</li>
<li>OPTIND : index of the next element to be processed</li>
</ul>
<p>TIP: No long option like &ldquo;<code>--file ...</code>&rdquo;.</p>
<p>The POSIX <code>getopts</code> is available as a shell buildin command of BASH/DASH.
(Please note <code>s</code> at the end. The older Bell Labs derived external command is
called <code>getopt</code>.)</p>
<h4 id="shell-script-long-and-short-option">Shell script (long and short option)</h4>
<p>Shell program with long and short command line options.</p>
<p>Source code for the shell script: cli_l</p>

<pre><code>#!/bin/sh
verbose=0
while [ &#34;$#&#34; -gt &#34;0&#34; ]; do
    case $1 in
    -a)    echo &#34;Option a&#34;
        ;;
    -f|--file)
        shift
        cat $1
        ;;
    -v)    verbose=1
        ;;
    --long)    echo &#34;Option long&#34;
        ;;
    --longextra)
        shift
        echo &#34;Option longextra with $1&#34;
        ;;
    --)    shift
        break 
        ;;
    -*)    echo &#34;Unknown option: $1&#34;
        echo &#34;Usage: $0 [-a] [-f|--file file] [-v] args ...&#34;
        exit 1
        ;;
    *)    break 
        ;;
    esac
    shift
done
printf &#34;Remaining arguments are: %s\n&#34; &#34;$*&#34;
</code></pre>

<p>TIP: You must type as &ldquo;<code>-a -f ...</code>&rdquo; and not as &ldquo;<code>-af ...</code>&rdquo;</p>
<p>Here I avoided the use of <code>getopts</code>/<code>getopt</code> for long option support to gain maximum portability.</p>
<h3 id="python">Python</h3>
<h4 id="python-script-with-argparse">Python script with argparse</h4>
<p>Simple example program with long and short command line options.</p>
<p>Source code for Python with argparse</p>

<pre><code>#!/usr/bin/python3
# vim:se tw=0 sts=4 ts=4 et cindent:
def main():
    import argparse, sys
    parser = argparse.ArgumentParser(description=&#39;This is skelton program.&#39;)
    parser.add_argument(&#39;-a&#39;, action=&#34;store_true&#34;, dest=&#34;opt_a&#34;, 
                    default=False, help=&#39;operation mode&#39;)
    parser.add_argument(&#39;-f&#39;, &#39;--file&#39;, action=&#34;store&#34;, dest=&#34;filename&#34;, 
                    help=&#39;input filename&#39;)
    parser.add_argument(&#39;-v&#39;, action=&#34;store_true&#34;, dest=&#34;verbose&#34;, 
                    default=False, help=&#39;vebosity&#39;)
    parser.add_argument(&#39;args&#39;, nargs=&#39;*&#39;, help=&#39;arguments&#39;)
    parser.add_argument(&#39;--long&#39;, action=&#34;store_true&#34;, dest=&#34;opt_long&#34;, 
                    help=&#39;long mode&#39;)
    parser.add_argument(&#39;--longextra&#39;, action=&#34;store&#34;, dest=&#34;long&#34;, 
                    help=&#39;long extra mode&#39;)
    args = parser.parse_args()
    if args.opt_a:
        print(&#34;option a&#34;)
    if args.filename:
        print(&#34;filename = &#34; &#43; args.filename)
        with open(args.filename) as f:
            for line in f:
                print (line[:-1])
    if args.verbose:
        print(&#34;option verbose&#34;)
    if args.opt_long:
        print(&#34;option long&#34;)
    if args.long:
        print(&#34;longextra = &#34; &#43; args.long)
    if args.args:
        print(&#34;args = &#34; , args.args)

if __name__ == &#39;__main__&#39;: 
    main()
</code></pre>

<p>Execution examples with auto generated help</p>

<pre><code>$ ./cli --help
usage: cli [-h] [-a] [-f FILENAME] [-v] [--long] [--longextra LONG]
           [args [args ...]]

This is skelton program.

positional arguments:
  args                  arguments

optional arguments:
  -h, --help            show this help message and exit
  -a                    operation mode
  -f FILENAME, --file FILENAME
                        input filename
  -v                    vebosity
  --long                long mode
  --longextra LONG      long extra mode
$ ./cli -avf BOGUS.txt --long --longextra=FOO cli BOGUS.txt
option a
filename = BOGUS.txt
This is BOGUS.txt here.
EOF here :-)
option verbose
option long
longextra = FOO
args =  [&#39;cli&#39;, &#39;BOGUS.txt&#39;]
$ ./cli -b
usage: cli [-h] [-a] [-f FILENAME] [-v] [--long] [--longextra LONG]
           [args [args ...]]
cli: error: unrecognized arguments: -b
</code></pre>

<p>TIP: Older programs may use <code>getopt</code> module which is not as object oriented as <code>argparse</code>.</p>
<p>See:</p>
<ul>
<li><a href="http://docs.python.org/3/library/argparse.html">&ldquo;argparse&rdquo; in &ldquo;The Python Standard Library&rdquo;</a>.</li>
<li><a href="http://docs.python.org/3/howto/argparse.html">&ldquo;Argparse Tutorial&rdquo; in &ldquo;Python HOWTOs&rdquo;</a>.</li>
<li>Comments in the file such as <code>/usr/lib/python3.2/argparse.py</code> providing the <code>argparse</code> module.</li>
</ul>
<p>Actual module file on the system can be obtained by running The Python interpreter interactively as follows.</p>
<pre tabindex="0"><code>$ /usr/bin/python3 -q
&gt;&gt;&gt; import argparse
&gt;&gt;&gt; print (argparse.__file__)
/usr/lib/python3.2/argparse.py
</code></pre><h4 id="python-script-with-cliapp">Python script with cliapp</h4>
<p><a href="http://code.liw.fi/cliapp/docs/">cliapp</a> is a Python framework for Unix-like
command line programs and provides a unified supports for the command line and
the configuration file.</p>
<p>This seems to be interesting and is used by the backup program <code>obnam</code>(1).</p>
<p>Source code for Python with cliapp</p>

<pre><code>#!/usr/bin/env python
# vim:se tw=0 sts=4 ts=4 et cindent:
&#39;&#39;&#39;
Example using cliapp framework. (Python2 only)
&#39;&#39;&#39;
import cliapp
import logging

class ExampleApp(cliapp.Application):

    def add_settings(self):
        self.settings.boolean([&#39;append&#39;, &#39;a&#39;], &#39;append mode&#39;)
        self.settings.string([&#39;file&#39;, &#39;f&#39;], &#39;configuration filename&#39;,
                metavar=&#39;FILENAME&#39;)
        self.settings.boolean([&#39;verbose&#39;, &#39;v&#39;], &#39;verbose mode&#39;)
        self.settings.boolean([&#39;long&#39;], &#39;long mode&#39;)
        self.settings.string([&#39;longextra&#39;], &#39;longextra mode&#39;,
                metavar=&#39;LONG&#39;)
    def process_inputs(self, args):
        self.counts = 0
        cliapp.Application.process_inputs(self, args)
        self.output.write(&#39;There were %s lines in %s.\n&#39;
            % (self.counts, args))
        print(&#39;append=%s&#39; % self.settings[&#39;append&#39;])
        print(&#39;verbose=%s&#39; % self.settings[&#39;verbose&#39;])
        print(&#39;long=%s&#39; % self.settings[&#39;long&#39;])
        print(&#39;longextra=%s&#39; % self.settings[&#39;longextra&#39;])
        if self.settings[&#39;file&#39;]:
           print(&#34;filename = %s&#34; % self.settings[&#39;file&#39;])
           with open(self.settings[&#39;file&#39;]) as f:
               for line in f:
                   print (line[:-1])

    def process_input_line(self, name, line):
        self.counts &#43;= 1

if __name__ == &#39;__main__&#39;:
    app = ExampleApp(&#39;Cli&#39;, version=&#39;0.1&#39;,
        description=&#34;Cli as a command line program example&#34;,
        epilog=&#34;Copyright (C) 2012 Osamu Aoki&#34;)
    app.settings.config_files = [&#39;example.conf&#39;]
    app.run()

</code></pre>

<p>Execution examples with auto generated help</p>

<pre><code>$ ./cli --help
Usage: Cli [options]

Cli as a command line program example

Options:
  --version             show program&#39;s version number and exit
  -h, --help            show this help message and exit
  --output=FILE         write output to FILE, instead of standard output
  -a, --append          append mode
  --no-append
  -f FILENAME, --file=FILENAME
                        configuration filename
  -v, --verbose         verbose mode
  --no-verbose
  --long                long mode
  --no-long
  --longextra=LONG      longextra mode

  Configuration files and settings:
    --dump-config       write out the entire current configuration
    --no-default-configs
                        clear list of configuration files to read
    --config=FILE       add FILE to config files
    --help-all          show all options

  Logging:
    --log=FILE          write log entries to FILE (default is to not write log
                        files at all); use &#34;syslog&#34; to log to system log, or
                        &#34;none&#34; to disable logging
    --log-level=LEVEL   log at LEVEL, one of debug, info, warning, error,
                        critical, fatal (default: debug)
    --log-max=SIZE      rotate logs larger than SIZE, zero for never (default:
                        0)
    --log-keep=N        keep last N logs (10)
    --log-mode=MODE     set permissions of new log files to MODE (octal;
                        default 0600)

  Peformance:
    --dump-memory-profile=METHOD
                        make memory profiling dumps using METHOD, which is one
                        of: none, simple, meliae, or heapy (default: simple)
    --memory-dump-interval=SECONDS
                        make memory profiling dumps at least SECONDS apart

Copyright (C) 2012 Osamu Aoki
$ ./cli -avf BOGUS.txt --long --longextra=FOO cli BOGUS.txt
There were 45 lines in [&#39;cli&#39;, &#39;BOGUS.txt&#39;].
append=True
verbose=True
long=True
longextra=FOO
filename = BOGUS.txt
This is BOGUS.txt here.
EOF here :-)
$ ./cli -b
Usage: Cli [options]

Cli: error: no such option: -b
</code></pre>

<h3 id="lua">Lua</h3>
<h4 id="lua-script-long-and-short-option">Lua script (long and short option)</h4>
<p>Simple example program with long and short command line options.</p>
<p>Source code for the Lua script: cli</p>

<pre><code>#!/usr/bin/lua
verbose = 0
i = 1
while (i &lt;= #arg) do
    if (arg[i] == &#39;-a&#39;) then
        print(&#34;Option a&#34;)
    elseif (arg[i] == &#39;-f&#39; or arg[i] == &#39;--file&#39;) then
        i = i &#43;1
        for line in io.lines(arg[i]) do
            print(line)
        end
    elseif (arg[i] == &#39;-v&#39;) then
        verbose = 1
    elseif (arg[i] == &#39;--long&#39;) then
        print(&#34;Option long&#34;)
    elseif (string.sub(arg[i],1,11) == &#39;--longextra&#39;) then
        print(&#34;Option longextra with &#34; .. string.sub(arg[i], 13))
    elseif (arg[i] == &#39;--&#39;) then
        i = i &#43;1
        break
    elseif (string.sub(arg[i], 1, 1) == &#39;-&#39;) then
        print(&#34;Unknown option: &#34; .. arg[i])
        print(&#34;Usage: &#34; .. arg[0] .. 
            &#34; [-a] [-f|--file file] [-v] [--long] [--longextra=value] [args...]&#34;)
        return(1)
    else
        break
    end
    i = i &#43; 1
end
i0 = i - 1
for i = 1, #arg - i0, 1 do
    print(&#34;ARG[&#34; .. i .. &#34;] = &#34; .. arg[i &#43; i0])
end

</code></pre>

<p>Execution examples with auto generated help</p>

<pre><code>$ ./cli --help
Unknown option: --help
Usage: ./cli [-a] [-f|--file file] [-v] [--long] [--longextra=value] [args...]
$ ./cli -a -v -f BOGUS.txt --long --longextra=FOO cli BOGUS.txt
Option a
Option long
Option longextra with FOO
ARG[1] = cli
ARG[2] = BOGUS.txt
$ ./cli -b
Unknown option: -b
Usage: ./cli [-a] [-f|--file file] [-v] [--long] [--longextra=value] [args...]
</code></pre>

<p>TIP: You must type as &ldquo;<code>-a -f ...</code>&rdquo; and not as &ldquo;<code>-af ...</code>&rdquo;</p>
<h3 id="perl">Perl</h3>
<h4 id="perl-script-with-getoptlong">Perl script with Getopt::Long</h4>
<p>Simple example program with long and short command line options.</p>
<p>Source code for Perl with <code>Getopt::Long</code></p>

<pre><code>#!/usr/bin/perl -w
use strict;
use Getopt::Long;
# Global variables
use vars qw(%opt $verbose $helpmsg);
%opt = ();
$verbose = 0;
$helpmsg = &#34;Usage: $0 [-a] [-v] [-f|--file name] [--long] [--longextra extra]...\n&#34;;

sub main()
{
    &amp;GetOptions(
        &#34;a&#34;=&gt;\$opt{&#39;a&#39;},
        &#34;f|file=s&#34;=&gt;\$opt{&#39;f&#39;},
        &#34;h|help&#34;=&gt;\$opt{&#39;h&#39;},
        &#34;v&#34;=&gt;\$opt{&#39;v&#39;},
        &#34;long&#34;=&gt;\$opt{&#39;long&#39;},
        &#34;longextra=s&#34;=&gt;\$opt{&#39;longextra&#39;}) or die $helpmsg; 
    if ($opt{&#39;a&#39;}) {
        print &#34;Option a\n&#34;;
    }
    if ($opt{&#39;h&#39;}) {
        print $helpmsg;
    }
    if ($opt{&#39;f&#39;}) {
        print(&#34;Option f with $opt{&#39;f&#39;}\n&#34;);
        open(INPUT_FILE, $opt{&#39;f&#39;})
            or die &#34;Couldn&#39;t open $opt{&#39;f&#39;}!&#34;;
        while (&lt;INPUT_FILE&gt;) {
            print &#34;$_&#34;;
        }
        close(INPUT_FILE)
    }
    if ($opt{&#39;v&#39;}) {
        $verbose = 1;
    }
    if ($opt{&#39;long&#39;}) {
        print &#34;Option long\n&#34;;
    }
    if ($opt{&#39;longextra&#39;}) {
        print &#34;Option f with $opt{&#39;longextra&#39;}\n&#34;;
    }
    if ($ARGV[0]) {
        print &#34;Other things found on the command line:\n&#34;;
    }
    foreach (@ARGV) {
        print &#34;ARG=$_\n&#34;;
    }
}

main();

</code></pre>

<p>TIP: Older programs with short command line options may use functions such as
<code>getopt(&quot;af:v&quot;)</code> or <code>getopts(&quot;af:v&quot;)</code> with <code>use Getopt::Std;</code> which set global
variables <code>$opt_a</code>, <code>$opt_f</code>, <code>$opt_v</code>.</p>
<p>Execution examples with auto generated help</p>

<pre><code>$ ./cli --help
Usage: ./cli [-a] [-v] [-f|--file name] [--long] [--longextra extra]...
$ ./cli -a -v -f BOGUS.txt --long --longextra=FOO cli BOGUS.txt
Option a
Option f with BOGUS.txt
This is BOGUS.txt here.
EOF here :-)
Option long
Option f with FOO
Other things found on the command line:
ARG=cli
ARG=BOGUS.txt
$ ./cli -b
Unknown option: b
Usage: ./cli [-a] [-v] [-f|--file name] [--long] [--longextra extra]...
</code></pre>

<h3 id="c">C</h3>
<p>Writing a code with the iteration over unknown length lines is not easy with C
since it requires dynamic memory allocation for the line buffer.  We will come
back to such coding later.</p>
<h4 id="c-with-getopt">C with getopt()</h4>
<p>Simple example program with short command line options.</p>
<p>Source code for C with getopt()</p>

<pre><code>/* a short command line option example */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt; /* getopt */
int main(int argc, char **argv)
{
    int c;
    int verbose = 0;
    while ((c = getopt(argc, argv, &#34;af:v&#34;)) != -1) {
        switch (c) {
        case &#39;a&#39;:
            printf(&#34;option a\n&#34;);
            break;
        case &#39;f&#39;:
            printf(&#34;option f with %s.\n&#34;, optarg);
            break;
        case &#39;v&#39;:
            verbose = 1;
            break;
        default:
            printf(&#34;unknown option = %c = ascii(0%x)\n&#34;,
                    optopt, optopt);
            printf(&#34;return value of getopt() = %c\n&#34;, c);
        }
    }
    printf(&#34;verbose mode = %i\n&#34;, verbose);
    if (optind &lt; argc) {
        int j = 1;
        while (optind &lt; argc) {
            printf(&#34;argument[%i]=%s\n&#34;, j, argv[optind&#43;&#43;]);
            j&#43;&#43;;
        }
    }
    return EXIT_SUCCESS;
}
</code></pre>

<p>Please note few global external variables used.</p>
<ul>
<li><code>char *optarg</code>  : pointer to the option argument string</li>
<li><code>int optind</code>    : index for the next argument to be processed</li>
<li><code>int opterr</code>    : set to zero for quieting error message</li>
<li><code>int optopt</code>    :</li>
</ul>
<h4 id="c-with-getopt_long">C with getopt_long()</h4>
<p>Simple example program with long and short command line options.</p>
<p>Source code for C with getopt_long()</p>

<pre><code>/* a long command line option example */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;getopt.h&gt;        /* getopt_long */

int main(int argc, char **argv)
{
    int c;
    int i = 0;
    int verbose = 0;
    static struct option longopts[] = {
        {&#34;append&#34;, no_argument, 0, &#39;a&#39;},
        {&#34;verbose&#34;, no_argument, 0, &#39;v&#39;},
        {&#34;file&#34;, required_argument, 0, &#39;f&#39;},
        {&#34;long&#34;, no_argument, 0, 0},
        {&#34;longextra&#34;, required_argument, 0, 0},
        {NULL, 0, NULL, 0}
    };
    while ((c = getopt_long(argc, argv, &#34;af:v&#34;, longopts, &amp;i)) != -1) {
        switch (c) {
        case 0: /* for longopts[all][3] == 0 */
            printf (&#34;option %s&#34;, longopts[i].name);
            if (optarg)
                printf (&#34; with arg %s&#34;, optarg);
            printf (&#34;\n&#34;);
            break;
        case &#39;a&#39;:
            printf(&#34;option a\n&#34;);
            break;
        case &#39;f&#39;:
            printf(&#34;option f with %s.\n&#34;, optarg);
            break;
        case &#39;v&#39;:
            verbose = 1;
            break;
        default:
            printf(&#34;unknown option = %c = ascii(0%x)\n&#34;, optopt, optopt);
            printf(&#34;return value of getopt_long() = %c\n&#34;, c);
        }
    }
    printf(&#34;verbose mode = %i\n&#34;, verbose);
    if (optind &lt; argc) {
        int j = 1;
        while (optind &lt; argc) {
            printf(&#34;argument[%i]=%s\n&#34;, j, argv[optind&#43;&#43;]);
            j&#43;&#43;;
        }
    }
    return EXIT_SUCCESS;
}

</code></pre>

<p>Please note few global external variables used just like <code>getopt()</code>.</p>
<p>In order to avoid GNU vs. BSD incompatibility, the following may be a good idea:</p>
<ul>
<li>Do not define <code>-W</code> option.</li>
<li>Third component of <code>longopts[]</code> must be 0. (as in the above example)</li>
<li>Always put all of arguments after all the options when calling the compiled program with <code>getopt_long()</code>.</li>
</ul>
<p>See <a href="http://www.unix.com/man-page/freebsd/3/getopt_long/">FreeBSD 8.0 getopt_long(3)</a> manual.</p>
<h3 id="c-1">C++</h3>
<p>The golden rule of C++ programing: &ldquo;If you can not find something in the C++ Standard Library, look for it in Boost libraries.&rdquo;</p>
<ul>
<li><a href="http://gcc.gnu.org/onlinedocs/gcc-4.7.1/libstdc">http://gcc.gnu.org/onlinedocs/gcc-4.7.1/libstdc</a>++/manual/[The GNU C++ Library]</li>
<li><a href="http://gcc.gnu.org/onlinedocs/gcc-4.7.1/libstdc">http://gcc.gnu.org/onlinedocs/gcc-4.7.1/libstdc</a>++/api/[libstdc++ Source Documentation]</li>
<li><a href="http://www.boost.org/">Boost C++ Libraries</a></li>
</ul>
<p>Simple example program with long and short command line options.</p>
<p>Source code for C++ with boost::program_options</p>

<pre><code>#include &lt;boost/program_options.hpp&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;stdlib.h&gt;
using namespace std;

// A helper function to simplify the main part.
template&lt;class T&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const vector&lt;T&gt;&amp; v)
{
    copy(v.begin(), v.end(), ostream_iterator&lt;T&gt;(cout, &#34; &#34;));
    return os;
}


int main(int argc, char **argv)
{
    string file;
    string extra;
    try {
        namespace po = boost::program_options;
        po::options_description visible(&#34;SYNTAX: cli [OPTION ...] files ...&#34;);
        visible.add_options()
            (&#34;append,a&#34;, &#34;append option&#34;)
            (&#34;help,h&#34;, &#34;help message&#34;)
            (&#34;verbose,v&#34;, &#34;verbose option&#34;)
            (&#34;file,f&#34;, po::value&lt;string&gt;(&amp;file), &#34;file option&#34;)
            (&#34;long&#34;, &#34;long option&#34;)
            (&#34;longextra&#34;, po::value&lt;string&gt;(&amp;extra), &#34;longextra option&#34;)
        ;
        po::options_description hidden;
        hidden.add_options()
            (&#34;input-file&#34;, po::value&lt; vector&lt;string&gt; &gt;(), &#34;input file&#34;)
        ;        
        po::positional_options_description p;
        p.add(&#34;input-file&#34;, -1);

        po::options_description desc;
        desc.add(visible).add(hidden);

        po::variables_map vm;
        po::store(po::command_line_parser(argc, argv)
            .options(desc).positional(p).run(), vm);
        po::notify(vm);    

        if (vm.count(&#34;help&#34;)) {
            cout &lt;&lt; visible &lt;&lt; &#34;\n&#34;;
            return EXIT_FAILURE;
        }
        if (vm.count(&#34;append&#34;)) {
            cout &lt;&lt; &#34;append mode\n&#34;;
        }
        if (vm.count(&#34;verbose&#34;)) {
            cout &lt;&lt; &#34;verbose mode\n&#34;;
        }
        if (vm.count(&#34;file&#34;)) {
            cout &lt;&lt; &#34;Filename: &#34; 
                 &lt;&lt; file &lt;&lt; &#34;\n&#34;;
        } else {
            cout  &lt;&lt; &#34;Filename: (unset)\n&#34;;
        }
        if (vm.count(&#34;long&#34;)) {
            cout &lt;&lt; &#34;long mode\n&#34;;
        }
        if (vm.count(&#34;longextra&#34;)) {
            cout &lt;&lt; &#34;Longextra: &#34; 
                 &lt;&lt; extra &lt;&lt; &#34;\n&#34;;
        } else {
            cout  &lt;&lt; &#34;Longextra: (unset)\n&#34;;
        }
        if (vm.count(&#34;input-file&#34;)) {
            cout &lt;&lt; &#34;Input files are: &#34;
                 &lt;&lt; vm[&#34;input-file&#34;].as&lt; vector&lt;string&gt; &gt;() &lt;&lt; &#34;\n&#34;;
        }
    }
    catch(exception&amp; e) {
        cerr &lt;&lt; &#34;E: &#34; &lt;&lt; e.what() &lt;&lt; &#34;\n&#34;;
        return EXIT_FAILURE;
    }
    catch(...) {
        cerr &lt;&lt; &#34;E: unknown type!\n&#34;;
    }

    return EXIT_SUCCESS;
}
</code></pre>

<p>Let&rsquo;s compile <code>cli.cxx</code> to create the ELF object <code>cli</code> and run it.</p>

<pre><code>$ g&#43;&#43; -Wall -lboost_program_options -o cli cli.cxx
$ ./cli -avf BOGUS.txt --long --longextra=FOO X1 X2
append mode
verbose mode
Filename: BOGUS.txt
long mode
Longextra: FOO
Input files are: X1 X2
$ ./cli -b
E: unknown option -b
$ ./cli --help
SYNTAX: cli [OPTION ...] files ...:
  -a [ --append ]       append option
  -h [ --help ]         help message
  -v [ --verbose ]      verbose option
  -f [ --file ] arg     file option
  --long                long option
  --longextra arg       longextra option

</code></pre>

<h3 id="vala">Vala</h3>
<p>Simple Vala example programs with long and short command line options using GLib.</p>
<h4 id="simple-non-oop-style-no-class">Simple non-OOP style (no class)</h4>
<p>Source code <code>cli-1.vala</code> in Vala language</p>

<pre><code>static bool append = false;
static bool verbose = false;
static bool op_long = false;
static string filename = null;
static string longextra = null;

// sources is a string array containing all non-option arguments
// https://mail.gnome.org/archives/vala-list/2009-March/msg00090.html
[CCode (array_length = false, array_null_terminated = true)]
static string[] sources;

const OptionEntry[] options = {
    { &#34;append&#34;,  &#39;a&#39;, 0, OptionArg.NONE,     ref append,
        &#34;Set append mode&#34;,     null },
    { &#34;verbose&#34;, &#39;v&#39;, 0, OptionArg.NONE,     ref verbose,
        &#34;Set verbose mode&#34;,    null },
    { &#34;file&#34;,    &#39;f&#39;, 0, OptionArg.FILENAME, ref filename,
        &#34;Use F file&#34;,         &#34;F&#34;},
    { &#34;long&#34;,      0, 0, OptionArg.NONE,     ref op_long,
        &#34;Set long mode&#34;,      null },
    { &#34;longextra&#34;, 0, 0, OptionArg.STRING,   ref longextra,
        &#34;Set longextra to M&#34;, &#34;M&#34; },
    { &#34;&#34;,    0, 0, OptionArg.FILENAME_ARRAY, ref sources,
        null,                &#34;FILE...&#34; },
    { null }
};


int main (string[] args) {
    // initialize locale
    Intl.setlocale (LocaleCategory.ALL, &#34;&#34;);
    //
    stdout.printf (&#34;command  = %s\n&#34;, args[0]);
    stdout.printf (&#34;basename = %s\n&#34;, Path.get_basename(args[0]));
    try {
        // parse command line options with GLib
        var opt_context = new OptionContext (&#34;- Cli&#34;);
        opt_context.set_help_enabled (true);
        opt_context.add_main_entries (options, null);
        opt_context.parse (ref args);
    } catch (OptionError e) {
        stdout.printf (&#34;%s\n&#34;, e.message);
        stdout.printf (
&#34;Run &#39;%s --help&#39; to see a full list of available command line options.\n&#34;,
            args[0]);
        return 1;
    }

    // print variables
    if (verbose) {
        stdout.printf (&#34;Cli: verbose ON\n&#34;);
    }
    if (append) {
        stdout.printf (&#34;Cli: appemd ON\n&#34;);
    }
    if (op_long) {
        stdout.printf (&#34;Cli: long ON\n&#34;);
    }
    if (filename != null) {
        stdout.printf (&#34;Cli: file = %s\n&#34;, filename);
    }
    if (longextra != null) {
        stdout.printf (&#34;Cli: longextra = %s\n&#34;, longextra);
    }
    if (sources != null) {
        int i = 0;
        foreach (string s in sources) {
            stdout.printf(&#34;sources[%i]=%s\n&#34;, i, s);
            i&#43;&#43;;
        }
    }
    return 0;
}


</code></pre>

<p>TIP: The above example skips specifying <code>GLib</code> for the parent class since it is
the default for Vala.</p>
<p>Let&rsquo;s compile <code>cli-1.vala</code> to create the ELF object <code>cli-1</code> and run it.</p>

<pre><code>$ valac -v cli-1.vala
/path/to/vala/cli-1.vala.c: In function ‘main’:
/path/to/vala/cli-1.vala.c:204:2: warning: ‘g_type_init’ is deprecated (declared ...
  g_type_init ();
  ^
Loaded package `/usr/share/vala-0.20/vapi/glib-2.0.vapi&#39;
Loaded package `/usr/share/vala-0.20/vapi/gobject-2.0.vapi&#39;
cc -o &#39;/path/to/vala/cli-1&#39; &#39;/path/to/vala/cli-1.vala.c&#39; -I/usr/include/glib-2.0 ...
$ ./cli-1 -avf BOGUS.txt --long --longextra=FOO X1 X2
command  = ./cli-1
basename = cli-1
Cli: verbose ON
Cli: appemd ON
Cli: long ON
Cli: file = BOGUS.txt
Cli: longextra = FOO
sources[0]=X1
sources[1]=X2
$ ./cli-1 -b
command  = ./cli-1
basename = cli-1
Unknown option -b
Run &#39;./cli-1 --help&#39; to see a full list of available command line options.
$ ./cli-1 --help
command  = ./cli-1
basename = cli-1
Usage:
  cli-1 [OPTION...] FILE... - Cli

Help Options:
  -h, --help        Show help options

Application Options:
  -a, --append      Set append mode
  -v, --verbose     Set verbose mode
  -f, --file=F      Use F file
  --long            Set long mode
  --longextra=M     Set longextra to M

</code></pre>

<p>You can get the C source as:</p>

<pre><code>$ valac -C cli-1.vala
$ wc -l cli-1.vala ; wc -l cli-1.c
75 cli-1.vala
221 cli-1.c
$ cat cli-1.c |sed -e &#39;s/       /    /g&#39;|fold  # tab =&gt; 4 spaces
/* cli-1.c generated by valac 0.20.1, the Vala compiler
 * generated from cli-1.vala, do not modify */


#include &lt;glib.h&gt;
#include &lt;glib-object.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;locale.h&gt;
#include &lt;stdio.h&gt;

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_co
ntext_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var),
NULL)))


extern gboolean append;
gboolean append = FALSE;
extern gboolean verbose;
gboolean verbose = FALSE;
extern gboolean op_long;
gboolean op_long = FALSE;
extern gchar* filename;
gchar* filename = NULL;
extern gchar* longextra;
gchar* longextra = NULL;
extern gchar** sources;
gchar** sources = NULL;

gint _vala_main (gchar** args, int args_length1);
static gint _vala_array_length (gpointer array);

const GOptionEntry options[7] = {{&#34;append&#34;, &#39;a&#39;, 0, G_OPTION_ARG_NONE, &amp;append,
&#34;Set append mode&#34;, NULL}, {&#34;verbose&#34;, &#39;v&#39;, 0, G_OPTION_ARG_NONE, &amp;verbose, &#34;Set
verbose mode&#34;, NULL}, {&#34;file&#34;, &#39;f&#39;, 0, G_OPTION_ARG_FILENAME, &amp;filename, &#34;Use F
file&#34;, &#34;F&#34;}, {&#34;long&#34;, (gchar) 0, 0, G_OPTION_ARG_NONE, &amp;op_long, &#34;Set long mode&#34;
, NULL}, {&#34;longextra&#34;, (gchar) 0, 0, G_OPTION_ARG_STRING, &amp;longextra, &#34;Set longe
xtra to M&#34;, &#34;M&#34;}, {&#34;&#34;, (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &amp;sources, NULL
, &#34;FILE...&#34;}, {NULL}};

gint _vala_main (gchar** args, int args_length1) {
    gint result = 0;
    FILE* _tmp0_;
    gchar** _tmp1_;
    gint _tmp1__length1;
    const gchar* _tmp2_;
    FILE* _tmp3_;
    gchar** _tmp4_;
    gint _tmp4__length1;
    const gchar* _tmp5_;
    gchar* _tmp6_ = NULL;
    gchar* _tmp7_;
    gboolean _tmp18_;
    gboolean _tmp20_;
    gboolean _tmp22_;
    const gchar* _tmp24_;
    const gchar* _tmp27_;
    gchar** _tmp30_;
    gint _tmp30__length1;
    GError * _inner_error_ = NULL;
    setlocale (LC_ALL, &#34;&#34;);
    _tmp0_ = stdout;
    _tmp1_ = args;
    _tmp1__length1 = args_length1;
    _tmp2_ = _tmp1_[0];
    fprintf (_tmp0_, &#34;command  = %s\n&#34;, _tmp2_);
    _tmp3_ = stdout;
    _tmp4_ = args;
    _tmp4__length1 = args_length1;
    _tmp5_ = _tmp4_[0];
    _tmp6_ = g_path_get_basename (_tmp5_);
    _tmp7_ = _tmp6_;
    fprintf (_tmp3_, &#34;basename = %s\n&#34;, _tmp7_);
    _g_free0 (_tmp7_);
    {
        GOptionContext* _tmp8_;
        GOptionContext* opt_context;
        GOptionContext* _tmp9_;
        GOptionContext* _tmp10_;
        GOptionContext* _tmp11_;
        _tmp8_ = g_option_context_new (&#34;- Cli&#34;);
        opt_context = _tmp8_;
        _tmp9_ = opt_context;
        g_option_context_set_help_enabled (_tmp9_, TRUE);
        _tmp10_ = opt_context;
        g_option_context_add_main_entries (_tmp10_, options, NULL);
        _tmp11_ = opt_context;
        g_option_context_parse (_tmp11_, &amp;args_length1, &amp;args, &amp;_inner_error_);
        if (_inner_error_ != NULL) {
            _g_option_context_free0 (opt_context);
            if (_inner_error_-&gt;domain == G_OPTION_ERROR) {
                goto __catch0_g_option_error;
            }
            _g_option_context_free0 (opt_context);
            g_critical (&#34;file %s: line %d: unexpected error: %s (%s, %d)&#34;, __FIL
E__, __LINE__, _inner_error_-&gt;message, g_quark_to_string (_inner_error_-&gt;domain)
, _inner_error_-&gt;code);
            g_clear_error (&amp;_inner_error_);
            return 0;
        }
        _g_option_context_free0 (opt_context);
    }
    goto __finally0;
    __catch0_g_option_error:
    {
        GError* e = NULL;
        FILE* _tmp12_;
        GError* _tmp13_;
        const gchar* _tmp14_;
        FILE* _tmp15_;
        gchar** _tmp16_;
        gint _tmp16__length1;
        const gchar* _tmp17_;
        e = _inner_error_;
        _inner_error_ = NULL;
        _tmp12_ = stdout;
        _tmp13_ = e;
        _tmp14_ = _tmp13_-&gt;message;
        fprintf (_tmp12_, &#34;%s\n&#34;, _tmp14_);
        _tmp15_ = stdout;
        _tmp16_ = args;
        _tmp16__length1 = args_length1;
        _tmp17_ = _tmp16_[0];
        fprintf (_tmp15_, &#34;Run &#39;%s --help&#39; to see a full list of available comma
nd line options.\n&#34;, _tmp17_);
        result = 1;
        _g_error_free0 (e);
        return result;
    }
    __finally0:
    if (_inner_error_ != NULL) {
        g_critical (&#34;file %s: line %d: uncaught error: %s (%s, %d)&#34;, __FILE__, _
_LINE__, _inner_error_-&gt;message, g_quark_to_string (_inner_error_-&gt;domain), _inn
er_error_-&gt;code);
        g_clear_error (&amp;_inner_error_);
        return 0;
    }
    _tmp18_ = verbose;
    if (_tmp18_) {
        FILE* _tmp19_;
        _tmp19_ = stdout;
        fprintf (_tmp19_, &#34;Cli: verbose ON\n&#34;);
    }
    _tmp20_ = append;
    if (_tmp20_) {
        FILE* _tmp21_;
        _tmp21_ = stdout;
        fprintf (_tmp21_, &#34;Cli: appemd ON\n&#34;);
    }
    _tmp22_ = op_long;
    if (_tmp22_) {
        FILE* _tmp23_;
        _tmp23_ = stdout;
        fprintf (_tmp23_, &#34;Cli: long ON\n&#34;);
    }
    _tmp24_ = filename;
    if (_tmp24_ != NULL) {
        FILE* _tmp25_;
        const gchar* _tmp26_;
        _tmp25_ = stdout;
        _tmp26_ = filename;
        fprintf (_tmp25_, &#34;Cli: file = %s\n&#34;, _tmp26_);
    }
    _tmp27_ = longextra;
    if (_tmp27_ != NULL) {
        FILE* _tmp28_;
        const gchar* _tmp29_;
        _tmp28_ = stdout;
        _tmp29_ = longextra;
        fprintf (_tmp28_, &#34;Cli: longextra = %s\n&#34;, _tmp29_);
    }
    _tmp30_ = sources;
    _tmp30__length1 = _vala_array_length (sources);
    if (_tmp30_ != NULL) {
        gint i;
        gchar** _tmp31_;
        gint _tmp31__length1;
        i = 0;
        _tmp31_ = sources;
        _tmp31__length1 = _vala_array_length (sources);
        {
            gchar** s_collection = NULL;
            gint s_collection_length1 = 0;
            gint _s_collection_size_ = 0;
            gint s_it = 0;
            s_collection = _tmp31_;
            s_collection_length1 = _tmp31__length1;
            for (s_it = 0; s_it &lt; _tmp31__length1; s_it = s_it &#43; 1) {
                gchar* _tmp32_;
                gchar* s = NULL;
                _tmp32_ = g_strdup (s_collection[s_it]);
                s = _tmp32_;
                {
                    FILE* _tmp33_;
                    gint _tmp34_;
                    const gchar* _tmp35_;
                    gint _tmp36_;
                    _tmp33_ = stdout;
                    _tmp34_ = i;
                    _tmp35_ = s;
                    fprintf (_tmp33_, &#34;sources[%i]=%s\n&#34;, _tmp34_, _tmp35_);
                    _tmp36_ = i;
                    i = _tmp36_ &#43; 1;
                    _g_free0 (s);
                }
            }
        }
    }
    result = 0;
    return result;
}


int main (int argc, char ** argv) {
    g_type_init ();
    return _vala_main (argv, argc);
}


static gint _vala_array_length (gpointer array) {
    int length;
    length = 0;
    if (array) {
        while (((gpointer*) array)[length]) {
            length&#43;&#43;;
        }
    }
    return length;
}



</code></pre>

<p>Since no OOP techniques are used, the resulting C code does not have GObject
related macros.</p>
<p>But some libraries from GLib are used, the resulting C code has automatically
generated memory management codes such as <code>_g_option_context_free0</code>,
<code>_g_error_free0</code>, and <code>_g_free0</code>.</p>
<h4 id="oop-style-main-outside-of-class">OOP style (main outside of class)</h4>
<p>Source code <code>cli-2.vala</code> in Vala language</p>

<pre><code>class Cli : Object {
    private static bool append = false;
    private static bool verbose = false;
    private static bool op_long = false;
    private static string filename = null;
    private static string longextra = null;

    // sources is a string array containing all non-option arguments
    // https://mail.gnome.org/archives/vala-list/2009-March/msg00090.html
    [CCode (array_length = false, array_null_terminated = true)]
    private static string[] sources;

    private const OptionEntry[] options = {
        { &#34;append&#34;,  &#39;a&#39;, 0, OptionArg.NONE,     ref append,
            &#34;Set append mode&#34;,     null },
        { &#34;verbose&#34;, &#39;v&#39;, 0, OptionArg.NONE,     ref verbose,
            &#34;Set verbose mode&#34;,    null },
        { &#34;file&#34;,    &#39;f&#39;, 0, OptionArg.FILENAME, ref filename,
            &#34;Use F file&#34;,         &#34;F&#34;},
        { &#34;long&#34;,      0, 0, OptionArg.NONE,     ref op_long,
            &#34;Set long mode&#34;,      null },
        { &#34;longextra&#34;, 0, 0, OptionArg.STRING,   ref longextra,
            &#34;Set longextra to M&#34;, &#34;M&#34; },
        { &#34;&#34;,    0, 0, OptionArg.FILENAME_ARRAY, ref sources,
            null,                &#34;FILE...&#34; },
        { null }
    };

    public int parse (string[] args) {
	// parse command line
        try {
            // parse command line options with GLib
            var opt_context = new OptionContext (&#34;- Cli&#34;);
            opt_context.set_help_enabled (true);
            opt_context.add_main_entries (options, null);
            opt_context.parse (ref args);
        } catch (OptionError e) {
            stdout.printf (&#34;%s\n&#34;, e.message);
            stdout.printf (
    &#34;Run &#39;%s --help&#39; to see a full list of available command line options.\n&#34;,
                args[0]);
            return 1;
        }
        return 0;
    }

    public int run () {
        // print variables
        if (verbose) {
            stdout.printf (&#34;Cli: verbose ON\n&#34;);
        }
        if (append) {
            stdout.printf (&#34;Cli: appemd ON\n&#34;);
        }
        if (op_long) {
            stdout.printf (&#34;Cli: long ON\n&#34;);
        }
        if (filename != null) {
            stdout.printf (&#34;Cli: file = %s\n&#34;, filename);
        }
        if (longextra != null) {
            stdout.printf (&#34;Cli: longextra = %s\n&#34;, longextra);
        }
        if (sources != null) {
            int i = 0;
            foreach (string s in sources) {
                stdout.printf(&#34;sources[%i]=%s\n&#34;, i, s);
                i&#43;&#43;;
            }
        }
        return 0;
    }

}
int main (string[] args) {
    // initialize locale
    Intl.setlocale (LocaleCategory.ALL, &#34;&#34;);
    //
    stdout.printf (&#34;command  = %s\n&#34;, args[0]);
    stdout.printf (&#34;basename = %s\n&#34;, Path.get_basename(args[0]));

    var cli = new Cli ();
    cli.parse (args);
    return cli.run ();
}

</code></pre>

<p>TIP: The above example skips specifying <code>GLib</code> for the parent class since it is
the default for Vala.</p>
<p>Let&rsquo;s compile <code>cli-2.vala</code> to create the ELF object <code>cli-2</code> and run it.</p>

<pre><code>$ valac -v cli-2.vala
/path/to/vala/cli-2.vala.c: In function ‘main’:
/path/to/vala/cli-2.vala.c:304:2: warning: ‘g_type_init’ is deprecated (declared ...
  g_type_init ();
  ^
Loaded package `/usr/share/vala-0.20/vapi/glib-2.0.vapi&#39;
Loaded package `/usr/share/vala-0.20/vapi/gobject-2.0.vapi&#39;
cc -o &#39;/path/to/vala/cli-2&#39; &#39;/path/to/vala/cli-2.vala.c&#39; -I/usr/include/glib-2.0 ...
$ ./cli-2 -avf BOGUS.txt --long --longextra=FOO X1 X2
command  = ./cli-2
basename = cli-2
Cli: verbose ON
Cli: appemd ON
Cli: long ON
Cli: file = BOGUS.txt
Cli: longextra = FOO
sources[0]=X1
sources[1]=X2
$ ./cli-2 -b
command  = ./cli-2
basename = cli-2
Unknown option -b
Run &#39;./cli-2 --help&#39; to see a full list of available command line options.
$ ./cli-2 --help
command  = ./cli-2
basename = cli-2
Usage:
  cli-2 [OPTION...] FILE... - Cli

Help Options:
  -h, --help        Show help options

Application Options:
  -a, --append      Set append mode
  -v, --verbose     Set verbose mode
  -f, --file=F      Use F file
  --long            Set long mode
  --longextra=M     Set longextra to M

</code></pre>

<p>You can get the C source as:</p>

<pre><code>$ valac -C cli-2.vala
$ wc -l cli-2.vala ; wc -l cli-2.c
86 cli-2.vala
321 cli-2.c
$ cat cli-2.c |sed -e &#39;s/       /    /g&#39;|fold  # tab =&gt; 4 spaces
/* cli-2.c generated by valac 0.20.1, the Vala compiler
 * generated from cli-2.vala, do not modify */


#include &lt;glib.h&gt;
#include &lt;glib-object.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;locale.h&gt;


#define TYPE_CLI (cli_get_type ())
#define CLI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLI, Cli))
#define CLI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CLI, CliClass))
#define IS_CLI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLI))
#define IS_CLI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CLI))
#define CLI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CLI, CliClass
))

typedef struct _Cli Cli;
typedef struct _CliClass CliClass;
typedef struct _CliPrivate CliPrivate;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_co
ntext_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var),
NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (va
r), NULL)))

struct _Cli {
    GObject parent_instance;
    CliPrivate * priv;
};

struct _CliClass {
    GObjectClass parent_class;
};


static gpointer cli_parent_class = NULL;
static gboolean cli_append;
static gboolean cli_append = FALSE;
static gboolean cli_verbose;
static gboolean cli_verbose = FALSE;
static gboolean cli_op_long;
static gboolean cli_op_long = FALSE;
static gchar* cli_filename;
static gchar* cli_filename = NULL;
static gchar* cli_longextra;
static gchar* cli_longextra = NULL;
static gchar** cli_sources;
static gchar** cli_sources = NULL;

GType cli_get_type (void) G_GNUC_CONST;
enum  {
    CLI_DUMMY_PROPERTY
};
gint cli_parse (Cli* self, gchar** args, int args_length1);
gint cli_run (Cli* self);
Cli* cli_new (void);
Cli* cli_construct (GType object_type);
static void cli_finalize (GObject* obj);
gint _vala_main (gchar** args, int args_length1);
static gint _vala_array_length (gpointer array);

static const GOptionEntry CLI_options[7] = {{&#34;append&#34;, &#39;a&#39;, 0, G_OPTION_ARG_NONE
, &amp;cli_append, &#34;Set append mode&#34;, NULL}, {&#34;verbose&#34;, &#39;v&#39;, 0, G_OPTION_ARG_NONE,
&amp;cli_verbose, &#34;Set verbose mode&#34;, NULL}, {&#34;file&#34;, &#39;f&#39;, 0, G_OPTION_ARG_FILENAME,
 &amp;cli_filename, &#34;Use F file&#34;, &#34;F&#34;}, {&#34;long&#34;, (gchar) 0, 0, G_OPTION_ARG_NONE, &amp;c
li_op_long, &#34;Set long mode&#34;, NULL}, {&#34;longextra&#34;, (gchar) 0, 0, G_OPTION_ARG_STR
ING, &amp;cli_longextra, &#34;Set longextra to M&#34;, &#34;M&#34;}, {&#34;&#34;, (gchar) 0, 0, G_OPTION_ARG
_FILENAME_ARRAY, &amp;cli_sources, NULL, &#34;FILE...&#34;}, {NULL}};

gint cli_parse (Cli* self, gchar** args, int args_length1) {
    gint result = 0;
    GError * _inner_error_ = NULL;
    g_return_val_if_fail (self != NULL, 0);
    {
        GOptionContext* _tmp0_;
        GOptionContext* opt_context;
        GOptionContext* _tmp1_;
        GOptionContext* _tmp2_;
        GOptionContext* _tmp3_;
        _tmp0_ = g_option_context_new (&#34;- Cli&#34;);
        opt_context = _tmp0_;
        _tmp1_ = opt_context;
        g_option_context_set_help_enabled (_tmp1_, TRUE);
        _tmp2_ = opt_context;
        g_option_context_add_main_entries (_tmp2_, CLI_options, NULL);
        _tmp3_ = opt_context;
        g_option_context_parse (_tmp3_, &amp;args_length1, &amp;args, &amp;_inner_error_);
        if (_inner_error_ != NULL) {
            _g_option_context_free0 (opt_context);
            if (_inner_error_-&gt;domain == G_OPTION_ERROR) {
                goto __catch0_g_option_error;
            }
            _g_option_context_free0 (opt_context);
            g_critical (&#34;file %s: line %d: unexpected error: %s (%s, %d)&#34;, __FIL
E__, __LINE__, _inner_error_-&gt;message, g_quark_to_string (_inner_error_-&gt;domain)
, _inner_error_-&gt;code);
            g_clear_error (&amp;_inner_error_);
            return 0;
        }
        _g_option_context_free0 (opt_context);
    }
    goto __finally0;
    __catch0_g_option_error:
    {
        GError* e = NULL;
        FILE* _tmp4_;
        GError* _tmp5_;
        const gchar* _tmp6_;
        FILE* _tmp7_;
        gchar** _tmp8_;
        gint _tmp8__length1;
        const gchar* _tmp9_;
        e = _inner_error_;
        _inner_error_ = NULL;
        _tmp4_ = stdout;
        _tmp5_ = e;
        _tmp6_ = _tmp5_-&gt;message;
        fprintf (_tmp4_, &#34;%s\n&#34;, _tmp6_);
        _tmp7_ = stdout;
        _tmp8_ = args;
        _tmp8__length1 = args_length1;
        _tmp9_ = _tmp8_[0];
        fprintf (_tmp7_, &#34;Run &#39;%s --help&#39; to see a full list of available comman
d line options.\n&#34;, _tmp9_);
        result = 1;
        _g_error_free0 (e);
        return result;
    }
    __finally0:
    if (_inner_error_ != NULL) {
        g_critical (&#34;file %s: line %d: uncaught error: %s (%s, %d)&#34;, __FILE__, _
_LINE__, _inner_error_-&gt;message, g_quark_to_string (_inner_error_-&gt;domain), _inn
er_error_-&gt;code);
        g_clear_error (&amp;_inner_error_);
        return 0;
    }
    result = 0;
    return result;
}


gint cli_run (Cli* self) {
    gint result = 0;
    gboolean _tmp0_;
    gboolean _tmp2_;
    gboolean _tmp4_;
    const gchar* _tmp6_;
    const gchar* _tmp9_;
    gchar** _tmp12_;
    gint _tmp12__length1;
    g_return_val_if_fail (self != NULL, 0);
    _tmp0_ = cli_verbose;
    if (_tmp0_) {
        FILE* _tmp1_;
        _tmp1_ = stdout;
        fprintf (_tmp1_, &#34;Cli: verbose ON\n&#34;);
    }
    _tmp2_ = cli_append;
    if (_tmp2_) {
        FILE* _tmp3_;
        _tmp3_ = stdout;
        fprintf (_tmp3_, &#34;Cli: appemd ON\n&#34;);
    }
    _tmp4_ = cli_op_long;
    if (_tmp4_) {
        FILE* _tmp5_;
        _tmp5_ = stdout;
        fprintf (_tmp5_, &#34;Cli: long ON\n&#34;);
    }
    _tmp6_ = cli_filename;
    if (_tmp6_ != NULL) {
        FILE* _tmp7_;
        const gchar* _tmp8_;
        _tmp7_ = stdout;
        _tmp8_ = cli_filename;
        fprintf (_tmp7_, &#34;Cli: file = %s\n&#34;, _tmp8_);
    }
    _tmp9_ = cli_longextra;
    if (_tmp9_ != NULL) {
        FILE* _tmp10_;
        const gchar* _tmp11_;
        _tmp10_ = stdout;
        _tmp11_ = cli_longextra;
        fprintf (_tmp10_, &#34;Cli: longextra = %s\n&#34;, _tmp11_);
    }
    _tmp12_ = cli_sources;
    _tmp12__length1 = _vala_array_length (cli_sources);
    if (_tmp12_ != NULL) {
        gint i;
        gchar** _tmp13_;
        gint _tmp13__length1;
        i = 0;
        _tmp13_ = cli_sources;
        _tmp13__length1 = _vala_array_length (cli_sources);
        {
            gchar** s_collection = NULL;
            gint s_collection_length1 = 0;
            gint _s_collection_size_ = 0;
            gint s_it = 0;
            s_collection = _tmp13_;
            s_collection_length1 = _tmp13__length1;
            for (s_it = 0; s_it &lt; _tmp13__length1; s_it = s_it &#43; 1) {
                gchar* _tmp14_;
                gchar* s = NULL;
                _tmp14_ = g_strdup (s_collection[s_it]);
                s = _tmp14_;
                {
                    FILE* _tmp15_;
                    gint _tmp16_;
                    const gchar* _tmp17_;
                    gint _tmp18_;
                    _tmp15_ = stdout;
                    _tmp16_ = i;
                    _tmp17_ = s;
                    fprintf (_tmp15_, &#34;sources[%i]=%s\n&#34;, _tmp16_, _tmp17_);
                    _tmp18_ = i;
                    i = _tmp18_ &#43; 1;
                    _g_free0 (s);
                }
            }
        }
    }
    result = 0;
    return result;
}


Cli* cli_construct (GType object_type) {
    Cli * self = NULL;
    self = (Cli*) g_object_new (object_type, NULL);
    return self;
}


Cli* cli_new (void) {
    return cli_construct (TYPE_CLI);
}


static void cli_class_init (CliClass * klass) {
    cli_parent_class = g_type_class_peek_parent (klass);
    G_OBJECT_CLASS (klass)-&gt;finalize = cli_finalize;
}


static void cli_instance_init (Cli * self) {
}


static void cli_finalize (GObject* obj) {
    Cli * self;
    self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CLI, Cli);
    G_OBJECT_CLASS (cli_parent_class)-&gt;finalize (obj);
}


GType cli_get_type (void) {
    static volatile gsize cli_type_id__volatile = 0;
    if (g_once_init_enter (&amp;cli_type_id__volatile)) {
        static const GTypeInfo g_define_type_info = { sizeof (CliClass), (GBaseI
nitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cli_class_init, (GClas
sFinalizeFunc) NULL, NULL, sizeof (Cli), 0, (GInstanceInitFunc) cli_instance_ini
t, NULL };
        GType cli_type_id;
        cli_type_id = g_type_register_static (G_TYPE_OBJECT, &#34;Cli&#34;, &amp;g_define_ty
pe_info, 0);
        g_once_init_leave (&amp;cli_type_id__volatile, cli_type_id);
    }
    return cli_type_id__volatile;
}


gint _vala_main (gchar** args, int args_length1) {
    gint result = 0;
    FILE* _tmp0_;
    gchar** _tmp1_;
    gint _tmp1__length1;
    const gchar* _tmp2_;
    FILE* _tmp3_;
    gchar** _tmp4_;
    gint _tmp4__length1;
    const gchar* _tmp5_;
    gchar* _tmp6_ = NULL;
    gchar* _tmp7_;
    Cli* _tmp8_;
    Cli* cli;
    gchar** _tmp9_;
    gint _tmp9__length1;
    gint _tmp10_ = 0;
    setlocale (LC_ALL, &#34;&#34;);
    _tmp0_ = stdout;
    _tmp1_ = args;
    _tmp1__length1 = args_length1;
    _tmp2_ = _tmp1_[0];
    fprintf (_tmp0_, &#34;command  = %s\n&#34;, _tmp2_);
    _tmp3_ = stdout;
    _tmp4_ = args;
    _tmp4__length1 = args_length1;
    _tmp5_ = _tmp4_[0];
    _tmp6_ = g_path_get_basename (_tmp5_);
    _tmp7_ = _tmp6_;
    fprintf (_tmp3_, &#34;basename = %s\n&#34;, _tmp7_);
    _g_free0 (_tmp7_);
    _tmp8_ = cli_new ();
    cli = _tmp8_;
    _tmp9_ = args;
    _tmp9__length1 = args_length1;
    cli_parse (cli, _tmp9_, _tmp9__length1);
    _tmp10_ = cli_run (cli);
    result = _tmp10_;
    _g_object_unref0 (cli);
    return result;
}


int main (int argc, char ** argv) {
    g_type_init ();
    return _vala_main (argv, argc);
}


static gint _vala_array_length (gpointer array) {
    int length;
    length = 0;
    if (array) {
        while (((gpointer*) array)[length]) {
            length&#43;&#43;;
        }
    }
    return length;
}



</code></pre>

<p>It is obvious that the Vala code is much shorter than the generated C code.
The Vala compiler took care chores of generating CPP macros for GObject
with.</p>
<ul>
<li>No prefix.</li>
<li><code>cli</code>, <code>CLI</code>, <code>Cli</code>: object type (= class) name</li>
<li><code>cli_get_type()</code>: returning GType of object CLI</li>
</ul>
<h4 id="oop-style-main-inside-of-class">OOP style (main inside of class)</h4>
<p>Source code <code>cli-3.vala</code> in Vala language</p>

<pre><code>class Cli : Object {
    private static bool append = false;
    private static bool verbose = false;
    private static bool op_long = false;
    private static string filename = null;
    private static string longextra = null;

    // sources is a string array containing all non-option arguments
    // https://mail.gnome.org/archives/vala-list/2009-March/msg00090.html
    [CCode (array_length = false, array_null_terminated = true)]
    private static string[] sources;

    private const OptionEntry[] options = {
        { &#34;append&#34;,  &#39;a&#39;, 0, OptionArg.NONE,     ref append,
            &#34;Set append mode&#34;,     null },
        { &#34;verbose&#34;, &#39;v&#39;, 0, OptionArg.NONE,     ref verbose,
            &#34;Set verbose mode&#34;,    null },
        { &#34;file&#34;,    &#39;f&#39;, 0, OptionArg.FILENAME, ref filename,
            &#34;Use F file&#34;,         &#34;F&#34;},
        { &#34;long&#34;,      0, 0, OptionArg.NONE,     ref op_long,
            &#34;Set long mode&#34;,      null },
        { &#34;longextra&#34;, 0, 0, OptionArg.STRING,   ref longextra,
            &#34;Set longextra to M&#34;, &#34;M&#34; },
        { &#34;&#34;,    0, 0, OptionArg.FILENAME_ARRAY, ref sources,
            null,                &#34;FILE...&#34; },
        { null }
    };

    private int parse (string[] args) {
	// parse command line
        try {
            // parse command line options with GLib
            var opt_context = new OptionContext (&#34;- Cli&#34;);
            opt_context.set_help_enabled (true);
            opt_context.add_main_entries (options, null);
            opt_context.parse (ref args);
        } catch (OptionError e) {
            stdout.printf (&#34;%s\n&#34;, e.message);
            stdout.printf (
    &#34;Run &#39;%s --help&#39; to see a full list of available command line options.\n&#34;,
                args[0]);
            return 1;
        }
        return 0;
    }

    private int run () {
        // print variables
        if (verbose) {
            stdout.printf (&#34;Cli: verbose ON\n&#34;);
        }
        if (append) {
            stdout.printf (&#34;Cli: appemd ON\n&#34;);
        }
        if (op_long) {
            stdout.printf (&#34;Cli: long ON\n&#34;);
        }
        if (filename != null) {
            stdout.printf (&#34;Cli: file = %s\n&#34;, filename);
        }
        if (longextra != null) {
            stdout.printf (&#34;Cli: longextra = %s\n&#34;, longextra);
        }
        if (sources != null) {
            int i = 0;
            foreach (string s in sources) {
                stdout.printf(&#34;sources[%i]=%s\n&#34;, i, s);
                i&#43;&#43;;
            }
        }
        return 0;
    }

    public static int main (string[] args) {
        // initialize locale
        Intl.setlocale (LocaleCategory.ALL, &#34;&#34;);
        //
        stdout.printf (&#34;command  = %s\n&#34;, args[0]);
        stdout.printf (&#34;basename = %s\n&#34;, Path.get_basename(args[0]));
    
        var cli = new Cli ();
        cli.parse (args);
        return cli.run ();
    }

}

</code></pre>

<p>TIP: The above example skips specifying <code>GLib</code> for the parent class since it is
the default for Vala.</p>
<p>Let&rsquo;s compile <code>cli-3.vala</code> to create the ELF object <code>cli-3</code> and run it.</p>

<pre><code>$ valac -v cli-3.vala
/path/to/vala/cli-3.vala.c: In function ‘main’:
/path/to/vala/cli-3.vala.c:263:2: warning: ‘g_type_init’ is deprecated (declared ...
  g_type_init ();
  ^
Loaded package `/usr/share/vala-0.20/vapi/glib-2.0.vapi&#39;
Loaded package `/usr/share/vala-0.20/vapi/gobject-2.0.vapi&#39;
cc -o &#39;/path/to/vala/cli-3&#39; &#39;/path/to/vala/cli-3.vala.c&#39; -I/usr/include/glib-2.0 ...
$ ./cli-3 -avf BOGUS.txt --long --longextra=FOO X1 X2
command  = ./cli-3
basename = cli-3
Cli: verbose ON
Cli: appemd ON
Cli: long ON
Cli: file = BOGUS.txt
Cli: longextra = FOO
sources[0]=X1
sources[1]=X2
$ ./cli-3 -b
command  = ./cli-3
basename = cli-3
Unknown option -b
Run &#39;./cli-3 --help&#39; to see a full list of available command line options.
$ ./cli-3 --help
command  = ./cli-3
basename = cli-3
Usage:
  cli-3 [OPTION...] FILE... - Cli

Help Options:
  -h, --help        Show help options

Application Options:
  -a, --append      Set append mode
  -v, --verbose     Set verbose mode
  -f, --file=F      Use F file
  --long            Set long mode
  --longextra=M     Set longextra to M

</code></pre>

<p>You can get the C source as:</p>

<pre><code>$ valac -C cli-3.vala
$ wc -l cli-3.vala ; wc -l cli-3.c
87 cli-3.vala
321 cli-3.c
$ cat cli-3.c |sed -e &#39;s/       /    /g&#39;|fold  # tab =&gt; 4 spaces
/* cli-3.c generated by valac 0.20.1, the Vala compiler
 * generated from cli-3.vala, do not modify */


#include &lt;glib.h&gt;
#include &lt;glib-object.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;locale.h&gt;


#define TYPE_CLI (cli_get_type ())
#define CLI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLI, Cli))
#define CLI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CLI, CliClass))
#define IS_CLI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLI))
#define IS_CLI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CLI))
#define CLI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CLI, CliClass
))

typedef struct _Cli Cli;
typedef struct _CliClass CliClass;
typedef struct _CliPrivate CliPrivate;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_co
ntext_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var),
NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (va
r), NULL)))

struct _Cli {
    GObject parent_instance;
    CliPrivate * priv;
};

struct _CliClass {
    GObjectClass parent_class;
};


static gpointer cli_parent_class = NULL;
static gboolean cli_append;
static gboolean cli_append = FALSE;
static gboolean cli_verbose;
static gboolean cli_verbose = FALSE;
static gboolean cli_op_long;
static gboolean cli_op_long = FALSE;
static gchar* cli_filename;
static gchar* cli_filename = NULL;
static gchar* cli_longextra;
static gchar* cli_longextra = NULL;
static gchar** cli_sources;
static gchar** cli_sources = NULL;

GType cli_get_type (void) G_GNUC_CONST;
enum  {
    CLI_DUMMY_PROPERTY
};
static gint cli_parse (Cli* self, gchar** args, int args_length1);
static gint cli_run (Cli* self);
gint cli_main (gchar** args, int args_length1);
Cli* cli_new (void);
Cli* cli_construct (GType object_type);
static void cli_finalize (GObject* obj);
static gint _vala_array_length (gpointer array);

static const GOptionEntry CLI_options[7] = {{&#34;append&#34;, &#39;a&#39;, 0, G_OPTION_ARG_NONE
, &amp;cli_append, &#34;Set append mode&#34;, NULL}, {&#34;verbose&#34;, &#39;v&#39;, 0, G_OPTION_ARG_NONE,
&amp;cli_verbose, &#34;Set verbose mode&#34;, NULL}, {&#34;file&#34;, &#39;f&#39;, 0, G_OPTION_ARG_FILENAME,
 &amp;cli_filename, &#34;Use F file&#34;, &#34;F&#34;}, {&#34;long&#34;, (gchar) 0, 0, G_OPTION_ARG_NONE, &amp;c
li_op_long, &#34;Set long mode&#34;, NULL}, {&#34;longextra&#34;, (gchar) 0, 0, G_OPTION_ARG_STR
ING, &amp;cli_longextra, &#34;Set longextra to M&#34;, &#34;M&#34;}, {&#34;&#34;, (gchar) 0, 0, G_OPTION_ARG
_FILENAME_ARRAY, &amp;cli_sources, NULL, &#34;FILE...&#34;}, {NULL}};

static gint cli_parse (Cli* self, gchar** args, int args_length1) {
    gint result = 0;
    GError * _inner_error_ = NULL;
    g_return_val_if_fail (self != NULL, 0);
    {
        GOptionContext* _tmp0_;
        GOptionContext* opt_context;
        GOptionContext* _tmp1_;
        GOptionContext* _tmp2_;
        GOptionContext* _tmp3_;
        _tmp0_ = g_option_context_new (&#34;- Cli&#34;);
        opt_context = _tmp0_;
        _tmp1_ = opt_context;
        g_option_context_set_help_enabled (_tmp1_, TRUE);
        _tmp2_ = opt_context;
        g_option_context_add_main_entries (_tmp2_, CLI_options, NULL);
        _tmp3_ = opt_context;
        g_option_context_parse (_tmp3_, &amp;args_length1, &amp;args, &amp;_inner_error_);
        if (_inner_error_ != NULL) {
            _g_option_context_free0 (opt_context);
            if (_inner_error_-&gt;domain == G_OPTION_ERROR) {
                goto __catch0_g_option_error;
            }
            _g_option_context_free0 (opt_context);
            g_critical (&#34;file %s: line %d: unexpected error: %s (%s, %d)&#34;, __FIL
E__, __LINE__, _inner_error_-&gt;message, g_quark_to_string (_inner_error_-&gt;domain)
, _inner_error_-&gt;code);
            g_clear_error (&amp;_inner_error_);
            return 0;
        }
        _g_option_context_free0 (opt_context);
    }
    goto __finally0;
    __catch0_g_option_error:
    {
        GError* e = NULL;
        FILE* _tmp4_;
        GError* _tmp5_;
        const gchar* _tmp6_;
        FILE* _tmp7_;
        gchar** _tmp8_;
        gint _tmp8__length1;
        const gchar* _tmp9_;
        e = _inner_error_;
        _inner_error_ = NULL;
        _tmp4_ = stdout;
        _tmp5_ = e;
        _tmp6_ = _tmp5_-&gt;message;
        fprintf (_tmp4_, &#34;%s\n&#34;, _tmp6_);
        _tmp7_ = stdout;
        _tmp8_ = args;
        _tmp8__length1 = args_length1;
        _tmp9_ = _tmp8_[0];
        fprintf (_tmp7_, &#34;Run &#39;%s --help&#39; to see a full list of available comman
d line options.\n&#34;, _tmp9_);
        result = 1;
        _g_error_free0 (e);
        return result;
    }
    __finally0:
    if (_inner_error_ != NULL) {
        g_critical (&#34;file %s: line %d: uncaught error: %s (%s, %d)&#34;, __FILE__, _
_LINE__, _inner_error_-&gt;message, g_quark_to_string (_inner_error_-&gt;domain), _inn
er_error_-&gt;code);
        g_clear_error (&amp;_inner_error_);
        return 0;
    }
    result = 0;
    return result;
}


static gint cli_run (Cli* self) {
    gint result = 0;
    gboolean _tmp0_;
    gboolean _tmp2_;
    gboolean _tmp4_;
    const gchar* _tmp6_;
    const gchar* _tmp9_;
    gchar** _tmp12_;
    gint _tmp12__length1;
    g_return_val_if_fail (self != NULL, 0);
    _tmp0_ = cli_verbose;
    if (_tmp0_) {
        FILE* _tmp1_;
        _tmp1_ = stdout;
        fprintf (_tmp1_, &#34;Cli: verbose ON\n&#34;);
    }
    _tmp2_ = cli_append;
    if (_tmp2_) {
        FILE* _tmp3_;
        _tmp3_ = stdout;
        fprintf (_tmp3_, &#34;Cli: appemd ON\n&#34;);
    }
    _tmp4_ = cli_op_long;
    if (_tmp4_) {
        FILE* _tmp5_;
        _tmp5_ = stdout;
        fprintf (_tmp5_, &#34;Cli: long ON\n&#34;);
    }
    _tmp6_ = cli_filename;
    if (_tmp6_ != NULL) {
        FILE* _tmp7_;
        const gchar* _tmp8_;
        _tmp7_ = stdout;
        _tmp8_ = cli_filename;
        fprintf (_tmp7_, &#34;Cli: file = %s\n&#34;, _tmp8_);
    }
    _tmp9_ = cli_longextra;
    if (_tmp9_ != NULL) {
        FILE* _tmp10_;
        const gchar* _tmp11_;
        _tmp10_ = stdout;
        _tmp11_ = cli_longextra;
        fprintf (_tmp10_, &#34;Cli: longextra = %s\n&#34;, _tmp11_);
    }
    _tmp12_ = cli_sources;
    _tmp12__length1 = _vala_array_length (cli_sources);
    if (_tmp12_ != NULL) {
        gint i;
        gchar** _tmp13_;
        gint _tmp13__length1;
        i = 0;
        _tmp13_ = cli_sources;
        _tmp13__length1 = _vala_array_length (cli_sources);
        {
            gchar** s_collection = NULL;
            gint s_collection_length1 = 0;
            gint _s_collection_size_ = 0;
            gint s_it = 0;
            s_collection = _tmp13_;
            s_collection_length1 = _tmp13__length1;
            for (s_it = 0; s_it &lt; _tmp13__length1; s_it = s_it &#43; 1) {
                gchar* _tmp14_;
                gchar* s = NULL;
                _tmp14_ = g_strdup (s_collection[s_it]);
                s = _tmp14_;
                {
                    FILE* _tmp15_;
                    gint _tmp16_;
                    const gchar* _tmp17_;
                    gint _tmp18_;
                    _tmp15_ = stdout;
                    _tmp16_ = i;
                    _tmp17_ = s;
                    fprintf (_tmp15_, &#34;sources[%i]=%s\n&#34;, _tmp16_, _tmp17_);
                    _tmp18_ = i;
                    i = _tmp18_ &#43; 1;
                    _g_free0 (s);
                }
            }
        }
    }
    result = 0;
    return result;
}


gint cli_main (gchar** args, int args_length1) {
    gint result = 0;
    FILE* _tmp0_;
    gchar** _tmp1_;
    gint _tmp1__length1;
    const gchar* _tmp2_;
    FILE* _tmp3_;
    gchar** _tmp4_;
    gint _tmp4__length1;
    const gchar* _tmp5_;
    gchar* _tmp6_ = NULL;
    gchar* _tmp7_;
    Cli* _tmp8_;
    Cli* cli;
    gchar** _tmp9_;
    gint _tmp9__length1;
    gint _tmp10_ = 0;
    setlocale (LC_ALL, &#34;&#34;);
    _tmp0_ = stdout;
    _tmp1_ = args;
    _tmp1__length1 = args_length1;
    _tmp2_ = _tmp1_[0];
    fprintf (_tmp0_, &#34;command  = %s\n&#34;, _tmp2_);
    _tmp3_ = stdout;
    _tmp4_ = args;
    _tmp4__length1 = args_length1;
    _tmp5_ = _tmp4_[0];
    _tmp6_ = g_path_get_basename (_tmp5_);
    _tmp7_ = _tmp6_;
    fprintf (_tmp3_, &#34;basename = %s\n&#34;, _tmp7_);
    _g_free0 (_tmp7_);
    _tmp8_ = cli_new ();
    cli = _tmp8_;
    _tmp9_ = args;
    _tmp9__length1 = args_length1;
    cli_parse (cli, _tmp9_, _tmp9__length1);
    _tmp10_ = cli_run (cli);
    result = _tmp10_;
    _g_object_unref0 (cli);
    return result;
}


int main (int argc, char ** argv) {
    g_type_init ();
    return cli_main (argv, argc);
}


Cli* cli_construct (GType object_type) {
    Cli * self = NULL;
    self = (Cli*) g_object_new (object_type, NULL);
    return self;
}


Cli* cli_new (void) {
    return cli_construct (TYPE_CLI);
}


static void cli_class_init (CliClass * klass) {
    cli_parent_class = g_type_class_peek_parent (klass);
    G_OBJECT_CLASS (klass)-&gt;finalize = cli_finalize;
}


static void cli_instance_init (Cli * self) {
}


static void cli_finalize (GObject* obj) {
    Cli * self;
    self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CLI, Cli);
    G_OBJECT_CLASS (cli_parent_class)-&gt;finalize (obj);
}


GType cli_get_type (void) {
    static volatile gsize cli_type_id__volatile = 0;
    if (g_once_init_enter (&amp;cli_type_id__volatile)) {
        static const GTypeInfo g_define_type_info = { sizeof (CliClass), (GBaseI
nitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cli_class_init, (GClas
sFinalizeFunc) NULL, NULL, sizeof (Cli), 0, (GInstanceInitFunc) cli_instance_ini
t, NULL };
        GType cli_type_id;
        cli_type_id = g_type_register_static (G_TYPE_OBJECT, &#34;Cli&#34;, &amp;g_define_ty
pe_info, 0);
        g_once_init_leave (&amp;cli_type_id__volatile, cli_type_id);
    }
    return cli_type_id__volatile;
}


static gint _vala_array_length (gpointer array) {
    int length;
    length = 0;
    if (array) {
        while (((gpointer*) array)[length]) {
            length&#43;&#43;;
        }
    }
    return length;
}



</code></pre>

<p>It is obvious that the Vala code is much shorter than the generated C code.
The Vala compiler took care chores of generating CPP macros for GObject
with.</p>
<ul>
<li>No prefix.</li>
<li><code>cli</code>, <code>CLI</code>, <code>Cli</code>: object type (= class) name</li>
<li><code>cli_get_type()</code>: returning GType of object CLI</li>
</ul>
<!-- raw HTML omitted -->


<table width="100%">
  <tbody>
  <tr>
  
  <td align="left" width="33%"><a href="/en/2013/08/02/fun2prog-hello/">Previous Post</a></td>
  
  <td align="center" width="33%"><a href="/en/">Top</a></td>
  
  <td align="right" width="33%"><a href="/en/2013/08/04/fun2prog-fibo/">Next Post</a></td>
  
  </tr>
  </tbody>
</table>

</main>

  <footer>
  
  
  <hr/>
  © 2013-2024 <a href="https://github.com/osamuaoki">Osamu Aoki</a>
  
  </footer>
  </body>
</html>

